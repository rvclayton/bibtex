.so bibtex.header
		  
@Article{pvsame,
  author       = "Boehm, Barry~W. and Gray, Terence~E. and Seewaldt, Thomas",
  title        = "Prototyping Versus Specifying:  {A} Multiproject Experiment",
  journal      = tse,
  year         = 1984,
  volume       = "SE-10",
  number       = 3,
  pages        = "290-302",
  month        = may,
  keywords     = "prototyping, specifying, requirements analysis, software
    engineering, software engineering education, software management, software
    metrics, cocomo, user interfaces",
  abstract     = "In this experiment, seven software teams developed versions
    of the same small-size (2000-4000 source instruction) application software
    product.  Four teams used the Specifying approach.  Three teams used the
    Prototyping approach.  The main results of the experiment were the
    following.  1) Prototyping yielded products with roughly equivalent
    performance, but with about 40 percent less code and 45 percent less
    effort.  2) The prototyped products rated somewhat lower on functionality
    and robustness, but higher on ease of use and ease of learning.  3)
    Specifying produced more coherent designs and software that was easier to
    integrate.  The paper presents the experimental data supporting these and a
    number of additional conclusions.", 
  location     = "http://dx.doi.org/10.1109/TSE.1984.5010238"
}
@Article{acsosapbhfi,
  author       = "Arnold, Matthew and Fink, Stephen and Sarkar, Vivek and Sweeney, Peter~F.",
  title        = "{A} Comparative Study of Static and Profile-Based Heuristics for Inlining",
  journal      = sigplan # " (" # pot # "Workshop on Dynamic and Adaptive
		  Compilation and Optimization - Dynamo '00)",
  year         = 2000,
  volume       = 35,
  number       = 7,
  pages        = "52--64",
  month        = jul,
  keywords     = "call graphs, inlining, program optimization, static analysis,
    dynamic analysis",
  abstract     = "In this paper, we present a comparative study of static and 
    profile-based heuristics for inlining.  Our motivation for this study is to
    use the results to design the best inlining algorithm that we can for the
    Jalapeño dynamic optimizing compiler for Java [6].  We use a well-known
    approximation algorithm for the KNAPSACK problem as a common
    “meta-algorithm” for the inlining heuristics studied in this paper.  We
    present performance results for an implementation of these inlining
    heuristics in the Jalapeño dynamic optimizing compiler.  Our performance
    results show that the inlining heuristics studied in this paper can lead to
    significant speedups in execution time (up to 1.68x) even with modest
    limits on code size expansion (at most 10%).",  
  location     = "http://dx.doi.org/10.1145/351403.351416"
}

@Article{cfsrmc,
  author       = "Iannino, Anthony and Musa, John~D. and Okumoto, Kazuhira and Littlewood, Bev",
  title        = "Criteria for Software Reliability Model Comparisons",
  journal      = tse,
  year         = 1983,
  volume       = 8,
  number       = 3,
  pages        = "12--16",
  month        = jul,
  keywords     = "model comparisons, predictive validity, software failures,
    software reliability, capability, assumption quality, applicability,
    simplicity",
  abstract     = "A set of criteria is proposed for the comparison of software
    reliability models.  The intention is to provide a logically organized
    basis for determining the superior models and for the presentation of model
    characteristics.  It is hoped that in the future, a software manager will
    be able to more easily select the model most suitable for his/her
    requirements from among the preferred ones.", 
  location     = "http://dx.doi.org/10.1145/1010891.1010893"
}

@Article{dotpedm,
  author       = "Barach, David~R. and Taenzer, David~H. and Wells, Robert~E.",
  title        = "Design of the {PEN} Editor Display Module",
  journal      = sigplan # " (" # pot # "ACM SIGPLAN SIGOA Symposium on Text Manipulation)",
  year         = 1981,
  volume       = 16,
  number       = 6,
  pages        = "130--136",
  month        = jun,
  keywords     = "software design, terminal handling, optimization",
  abstract     = "PEN, a new portable video editor, uses a number of simple but
    effective techniques.  Most are not new, but are unavailable in the
    literature.  We will describe our goals for PEN's display module, discuss
    implementation alternatives and describe in detail the techniques used in
    the editor.", 
  location     = "http://dx.doi.org/10.1145/800209.806464"
}
@Book{dsdi,
  author       = "Daniel~C. Dennett",
  title        = "Darwin's Dangerous Idea",
  publisher    = "Simon \& Schuster",
  year         = 1995,
  address      = nyny,
  keywords     = "evolution, darwin, scientific debate",
  location     = "QH 375 D45"
}

@Article{rtpt,
  author       = "Thomas~H. {Cheatham, Jr.}",
  title        = "Reusability Through Program Transformation",
  journal      = tse,
  year         = 1984,
  volume       = "SE-10",
  number       = 5,
  pages        = "574--588",
  month        = sep,
  keywords     = "programming environments, porgram transformations, rapid
    prototyping, reusability, specification languages",
  abstract     = "We describe a methodology and supporting programming
    environment that provide for reuse of abstract programs.  Abstract programs
    are written using notations and constructs natural to the problem domain in
    a language realized by syntactic extension of a base language.  Program
    transformations are employed to refine an abstract program into its
    concrete counterpart.  We discuss the use of the methodology in the setting
    of rapid prototyping and custom tailoring.", 
  location     = "http://dx.doi.org/10.1109/TSE.1984.5010282"
}

@Article{arajg,
  author       = "James Gosling",
  title        = "{A} Redisplay Algorithm",
  journal      = sigplan # " (" # pot # "ACM SIGPLAN SIGOA Symposium on Text Manipulation)",
  year         = 1981,
  volume       = 16,
  number       = 6,
  pages        = "123--129",
  month        = jun,
  keywords     = "dynamic programming",
  abstract     = "This paper presents an algorithm for updating the image
    displayed on a conventional video terminal.  It assumes that the terminal
    is capable of doing the usual insert/delete line and insert/delete
    character operations.  It takes as input a description of the image
    currently on the screen and a description of the new image desired and
    produces a series of operations to do the desired transformation in a
    near-optimal manner.  The algorithm is interesting because it applies
    results from the theoretical string-to-string correction problem (a
    generalization of the problem of finding a longest common subsequence), to
    a problem that is usually approached with crude ad-hoc techniques.", 
  location     = "http://dx.doi.org/10.1145/872730.806463"
}

@Article{otlbpitf,
  author       = "Achugbue, James~O.",
  title        = "On the Line Breaking Problem in Text Formatting",
  journal      = sigplan # " (" # pot # "ACM SIGPLAN SIGOA Symposium on Text Manipulation)",
  year         = 1981,
  volume       = 16,
  number       = 6,
  pages        = "117--122",
  month        = jun,
  keywords     = "line breaking, text formatting, dynamic programming",
  abstract     = "A basic problem in text formatting is that of determining the
    break points for separating a string of words into lines to obtain a
    formatted paragraph.  When formatted text is required to be aligned with
    both the left and right margins, the choice of break points greatly affects
    the quality of the formatted document.  This paper presents and discusses
    solutions to the line breaking problem.  These include the usual
    line-by-line method, a dynamic programming approach, and a new algorithm
    which is optimal and runs almost as fast as the line-by-line method.", 
  location     = "http://dx.doi.org/10.1145/800209.806462"
}

@Article{esopk,
  author       = "Soloway, Elliot and Ehrlich, Kate",
  title        = "Emperical Studies of Programming Knowledge",
  journal      = tse,
  year         = 1984,
  volume       = "SE-10",
  number       = 5,
  pages        = "595--609",
  month        = sep,
  keywords     = "cognitive models of programming, novice/expert differences,
    program comprehension, software psychology",
  abstract     = "We suggest that expert programmers have and use two types of 
    programming knowledge: 1) programming plans, which are generic program
    fragments that represent stereotypic action sequences in programming, and
    2) rules of programming discourse, which capture the conventions in
    programming and govern the composition of the plans into programs.  We
    report here on two empirical studies that attempt to evaluate the above
    hypothesis.  Results from these studies do in fact support our claim.", 
  location     = "http://dx.doi.org/10.1109/TSE.1984.5010283"
}

@Article{prtpt,
  author       = "Boyle, James~M. and Muralidharan, Monagur~N.",
  title        = "Program Reusability through Program Transformation",
  journal      = tse,
  year         = 1984,
  volume       = "SE-10",
  number       = 5,
  pages        = "574--588",
  month        = sep,
  keywords     = "abstract programming, canonical forms, optimization, program
    transformation, pure applicative lisp, rewrite rules, stepwise refinement,
    tampr",
  abstract     = "How can a program written in pure applicative LISP be reused
    in a Fortran environment? One answer is by automatically transforming it
    from LISP into Fortran.  In this paper we discuss a practical application
    of this technique-one that yields an efficient Fortran program.  We view
    this process as an example of abstract programming, in which the LISP
    program constitutes an abstract specification for the Fortran version.  The
    idea of strategy-a strategy for getting from LISP to Fortran-is basic to
    designing and applying the transformations.  One strategic insight is that
    the task is easier if the LISP program is converted to ``recursive''
    Fortran, and then the recursive Fortran program is converted to
    nonrecursive standard Fortran.  Another strategic insight is that much of
    the task can be accomplished by converting the program from one canonical
    form to another.  Developing a strategy also involves making various
    implementation decisions.  One advantage of program transformation
    methodology is that it exposes such decisions for examination and review.
    Another is that it enables optimizations to be detected and implemented
    easily.  Once a strategy has been discovered, it can be implemented by
    means of rewrite-rule transformations using the TAMPR program
    transformation system.  The transformational approach to program reuse
    based on this strategy has a measure of elegance.  It is also practical-the
    resulting Fortran program is 25 percent faster than its compiled LISP
    counterpart, even without extensive optimization.", 
  location     = "http://dx.doi.org/10.1109/TSE.1984.5010281"
}

@Article{tioeaiaidps,
  author       = "Hammer, Michael and Ilson, Richard and Anderson, Tim and Gilbert, Edward and Good, Michael and Niamir, Bahram and Rosentein, Larry and Schoichet, Sandor",
  title        = "The Implementation of {E}tude, An integrated and Interactive Document Production System",
  journal      = sigplan # " (" # pot # "ACM SIGPLAN SIGOA Symposium on Text Manipulation)",
  year         = 1981,
  volume       = 16,
  number       = 6,
  pages        = "117--122",
  month        = jun,
  keywords     = "software design, user-interface design, document
    representation",
  abstract     = "Etude is an experimental text processing system that is being
    developed in order to formulate and evaluate new approaches to the design
    of user interfaces for office automation tools.  The primary design goal
    for Etude is to provide the user with substantial functionality in the
    editing and formatting of documents in the context of a system that is easy
    to learn and use.", 
  location     = "http://dx.doi.org/10.1145/800209.806465"
}

@Article{aisercdcall,
  author       = "Ben-David, Amram and Ben-Porath, Moshe~I. and Loeb, Jonah~Z. and Rich, Michael",
  title        = "An Industrial Software Engineering Retraining Course:  Development Considerations and Lessons Learned",
  journal      = tse,
  year         = 1984,
  volume       = "SE-10",
  number       = 6,
  pages        = "748--755",
  month        = nov,
  keywords     = "",
  abstract     = "Israel Aircraft Industries has recently been conducting a novel
    six-month intensive course to retrain practicing engineers to become
    software engineers working on embedded computer systems.  The first course
    was concluded in January 1982 and the second course began in November 1982.
    This paper describes the objectives, educational philosophy, course
    content, and practical experience of the first course.  It also describes
    how the second course was modified as a result of the lessons learned from
    the successes and failures of the first course.", 
  location     = "http://dx.doi.org/10.1109/TSE.1984.5010303"
}

@Article{acgpoi,
  author       = "Corrigan, Neil~B. and Starkey, J.~Denbigh",
  title        = "{A} Concurrent General Purpose Operator Interface",
  journal      = tse,
  year         = 1984,
  volume       = "SE-10",
  number       = 6,
  pages        = "738--748",
  month        = nov,
  keywords     = "computer graphics, concurrent pascal, concurrent programming,
    interactive system, man-machine interface, operator interface, process
    control",
  abstract     = "Compact interactive control consoles are rephcing traditional
    control rooms as operator interfaces for physical processes.  In the irust
    major application of concurrent programming outside the area of operating
    systems, this paper presents a design for a general purpose operator
    interface which uses a color graphics terminal with a touch-sensitive
    screen as the control console.  Operators interact with a process through a
    collection of application-dependent displays generated interactively by
    users familiar with the physical process.  The use of concurrent
    programming results in a straightforward and reliable design which may
    easily be extended to support multiple devices of varying types in the
    control console.  An implementation of the Operator Interface in Concurrent
    Pascal currently in progress is also discussed.", 
  location     = "http://dx.doi.org/10.1109/TSE.1984.5010302"
}

@Article{eoerbufcp,
  author       = "Kang~G. Shin and Yann-Hang Lee",
  title        = "Evaluation of Error Recovery Blocks Used for Cooperating Processes",
  journal      = tse,
  year         = 1984,
  volume       = "SE-10",
  number       = 6,
  pages        = "692--700",
  month        = nov,
  keywords     = "backward error recovery, conversation scheme, domino effect,
    pseudorecovery points and line(s), recovery block(s), recovery line(s),
    rollback propagations",
  abstract     = "Three alternatives for implementing recovery blocks (RB's) 
    are conceivable for backward error recovery in concurrent processing.
    These are the asynchronous, synchronous, and the pseudorecovery point
    implementations.  Asynchronous RB's are based on the concept of maximum
    autonomy in each of concurrent processes.  Consequently, establishment of
    RB's in a process is made independently of others and unbounded rollback
    propagations become a serious problem.  In order to completely avoid
    unbounded rollback propagations, it is necessary to synchronize the
    establishment of recovery blocks in all cooperating processes.  Process
    autonomy is sacrificed and processes are forced to wait for commitments
    from others to establish a recovery line, leading to inefficiency in time
    utilization.  As a compromise between asynchronous and synchronous RB's we
    propose to insert pseudorecovery points (PRP's) so that unbounded rollback
    propagations may be avoided while maintaining process autonomy.  We
    developed probabilistic models for analyzing these three methods under
    standard assumptions in computer performance analysis, i.e., exponential
    distributions for related random variables.  With these models we have
    estimated 1) the interval between two successive recovery lines for
    asynchronous RB's, 2) mean loss in computation power for the synchronized
    method, and 3) additional overhead and rollback distance in case PRP's are
    used.", 
  location     = "http://dx.doi.org/10.1109/TSE.1984.5010298"
}

@Article{rtem,
  author       = "Bernhard Plattner",
  title        = "Real-Time Execution Monitoring",
  journal      = tse,
  year         = 1984,
  volume       = "SE-10",
  number       = 6,
  pages        = "756--764",
  month        = nov,
  keywords     = "debugging, monitor, performance evaluation, process
    interaction, process monitor, real-time monitoring, timing",
  abstract     = "Today's programming methodology emphasizes the study of static
    aspects of programs.  In practice, however, monitoring a program in
    execution, i.e., monitoring a process, is routinely done by any programmer
    whose task it is to produce a reliable piece of software.  There are two
    reasons why one might want to examine the dynamic aspects of a program:
    first, to evaluate the performance of a program, and hence to assess its
    overall behavior; and second, to demonstrate the presence of programming
    errors, isolate erroneous program code, and correct it.  This latter task
    is commonly called ``debugging a program'' and requires a detailed insight
    into the innards of a program being executed.  Today, many computer systems
    are being used to measure and control real-world processes.  The pace of
    execution of these systems and their control programs is therefore bound to
    timing constraints imposed by the real-world process.  As a step towards
    solving the problems associated with execution monitoring of real-time
    programs, we develop a set of appropriate concepts and define the basic
    requirements for a real-time monitoring facility.  As a test case for the
    theoretical treatment of the topic, we design hardware and software for an
    experimental real-time monitoring system and describe its implementation.", 
  location     = "http://dx.doi.org/10.1109/TSE.1984.5010304"
}

@Article{dcobnfgpc,
  author       = "Alan Mainwaring and David~E. Culler",
  title        = "Design Challenges of Virtual Networks:  Fast, General-Purpose Communication",
  journal      = sigplan # " (" # pot # "Seventh ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming)",
  year         = 1999,
  volume       = 34,
  number       = 8,
  pages        = "119--130",
  month        = aug,
  keywords     = "virtual networks, high-performance clusters, direct network
    access, application programming interfaces, system resource management,
    protocol architecture and implementation",
  abstract     = "Virtual networks provide applications with the illusion of 
    having their own dedicated, high-performance networks, although network
    interfaces posses limited, shared resources.  We present the design of a
    large-scale virtual network system and examine the integration of
    communication programming interface, system resource management, and
    network interface operation.  Our implementation on a cluster of 100
    workstations quantifies the impact of virtualization on small message
    latencies and throughputs, shows full hardware performance is delivered to
    dedicated applications and time-shared workloads, and shows robust
    performance under demanding workloads that overcommit interface
    resources.", 
  location     = "http://dx.doi.org/10.1145/329366.301115"
}

@Article{aeiojsrmi,
  author       = "Maassen, Jason and {van Nieuwpoort}, Rob and Veldema, Ronald and Bal, Henri~E. and Plaat, Aske",
  title        = "An Efficient Implementation of {J}ava's {R}emote {M}ethod {I}nvocation",
  journal      = sigplan # " (" # pot # "Seventh ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming)",
  year         = 1999,
  volume       = 34,
  number       = 8,
  pages        = "173--182",
  month        = aug,
  keywords     = "java, rmi, performance, native-code compilation",
  abstract     = "Java offers interesting opportunities for parallel computing.
    In particular, Java Remote Method Invocation provides an unusually flexible
    kind of Remote Procedure Call.  Unlike RPC, RMI supports polymorphism,
    which requires the system to be able to download remote classes into a
    running application.  Sun's RMI implementation achieves this kind of
    flexibility by passing around object type information and processing it at
    run time, which causes a major run time overhead.  Using Sun's JDK 1.1.4 on
    a Pentium Pro/Myri.net cluster, for example, the latency for a null RMI
    (without parameters or a return value) is 1228 &mu;sec, which is about a
    factor of 40 higher than that of a user-level RPC.  In this paper, we study
    an alternative approach for implementing RMI, based on native compilation.
    This approach allows for better optimization, eliminates the need for
    processing of type information at run time, and makes a light weight
    communication protocol possible.  We have built a Java system based on a
    native compiler, which supports both compile time and run time generation
    of marshallers.  We find that almost all of the run time overhead of RMI
    can be pushed to compile time.  With this approach, the latency of a null
    RMI is reduced to 34 &mu;sec, while still supporting polymorphic RMIs (and
    allowing interoperability with other JVMs).", 
  location     = "http://dx.doi.org/10.1145/301104.301120"
}

@Book{osid,
  author       = "Thomas~W. Doeppner",
  title        = "Operating Systems in Depth",
  publisher    = "Wiley",
  year         = 2011,
  keywords     = "operating systems, multithreaded programming, processor
    management, file systems, memory management, security, networking,
    distributed file systems",
  location     = "QA 76.76.O63 D64"
}

@Book{aiama,
  author       = "Stuart Russell and Peter Norvig",
  title        = "Artificial Intelligence: {A} Modern Approach",
  publisher    = "Prentice Hall",
  year         = 2010,
  address      = srnj,
  edition      = "third",
  keywords     = "artificial intelligence, agents, search, constraint
    satisfaction, first-order logic, inference, planning, knowledge
    representations, uncertainty, probabilistic reasoning, decision making,
    leaning, natural language processing, perception, robotics",
  location     = "Q 335 R86"
}

@Book{isppap,
  author       = "Robert~J. Schalkoff",
  title        = "Intelligent Systems:  Principles, Pradigms, and Pragmatics",
  publisher    = "Jones and Bartlett",
  year         = 2011,
  address      = "Sudbury, " # MA,
  keywords     = "search, constraint satisfaction, natural language
    understanding, production systems, soar, uncertainty, fuzzy systems,
    planning, neural networks, learning, evolutionary computing",
  location     = "QA 76.76 I58 S323"
}

@InBook{lphoor,
  author       = "Hamdy~A. Taha",
  title        = "Handbook of Operations Research",
  chapter      = "II-1: Linear Programming",
  publisher    = "Van Nostrand Reinhold",
  year         = 1978,
  editor       = "Joseph~J. Moder and Salah~E. Elmaghraby",
  pages        = "85--119",
  address      = nyny,
  keywords     = "linear programming, the simplex method, duality theory,
    sensitivity analyses",
  location     = "T 57.6.H35"
}

@TechReport{rsurr,
  author       = "Fr{\' e}d{\' e}ric Boussinot",
  title        = "{RC} Semantics using Rewriting Rules",
  institution  = "Centre de Math{\' e}matiques Appliqu{\' e}es, Ecole des Mines
  de Paris",
  year         = 1992,
  number       = "18--92",
  address      = "Sophia-Antipolis, France",
  month        = "23 " # sep,
  keywords     = "rewriting rules, semantics, rc, reactive semantics",
  abstract     = "This paper describes a formal semantics for a new
     programming language called reactive C.  This language is an extension of
     C to program reactive systems i.e.  systems that react to sequences of
     activations from the external world.  Reactive statements are introduced
     to code these systems.  The semantics of reactive statements is described
     in an operational framework using conditional rewriting rules.", 
  location     = "http://www-sop.inria.fr/meije/rp/RapportsRecherche/rapport18-92.pdf"
}

@TechReport{pbacus4,
  author       = "Mario Wolczko and Randall~B. Smith",
  title        = "Prototype-Based Application Construction Using {S}elf 4.0",
  institution  = "Sun Microsystems Laboratories",
  year         = 1995,
  number       = "SMLI 95-0257",
  address      = mvca,
  keywords     = "self, prototypical programming",
  location     = "https://www.cs.ucsb.edu/~urs/oocsb/self/release/Self-4.0/manuals/tutorial.ps.gz"
}

