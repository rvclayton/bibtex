.so bibtex.header
		  
@string{ir95  = " (ACM SIGPLAN Workshop on Intermediate Representations, IR '95)"}
		  
@Book{tdoetn,
  author       = "Tom Nichols",
  title        = "The Death of Expertise",
  publisher    = oup,
  year         = 2017,
  address      = nyny,
  keywords     = "expertise, knowledge, politics, technocracy, education,
    media, merit", 
  location     = "HM 851.N54"
}

@Book{tsrjb,
  author       = "John Brunner",
  title        = "The Shockwave Rider",
  publisher    = "Harper \& Row",
  year         = 1975,
  address      = nyny,
  keywords     = "future, networking, security, secrecy",
  location     = "PR 6052.R8"
}

@Book{srs,
  author       = "Robin Sloan",
  title        = "Sourdough",
  publisher    = "Farrar, Straus and Giroux",
  year         = 2017,
  address      = nyny,
  keywords     = "techology, food science, breadmaking",
  location     = "PS 3619.L6278 S67"
}

@Book{snttd,
  author       = "Ian Zack",
  title        = "Say No to the Devil",
  publisher    = ucp,
  year         = 2015,
  address      = chil,
  keywords     = "blues, gary davis, guitarists, street preachers, folk music",
  location     = "ML 419.D386 Z33"
}

@Book{dicnm,
  author       = "Nancy MacLean",
  title        = "Democracy in Chains",
  publisher    = "Viking",
  year         = 2017,
  address      = nyny,
  keywords     = "libertarianism, democracy, the kochs, james buchanan, public
    choice economics, governance",
  location     = "HN 49.R33 M23"
}

@Book{plpip,
  author       = "Steve Gregory",
  title        = "Parallel Logic Programming in {PARLOG}",
  publisher    = "Addison-Wesley",
  year         = 1987,
  address      = "Wokingham, England",
  keywords     = "parallel logic programming, parlog, and/or tree model, and
    tree model, compile-time analysis",
  location     = "QA 76.73.P194 G74"
}

@Book{tghsr,
  author       = "Salman Rushdie",
  title        = "The Golden House",
  publisher    = "Random House",
  year         = 2017,
  address      = nyny,
  keywords     = "2016 us election, crime, india, visual artists",
  location     = "PR 6068.U757 G65"
}

@Book{tjgrbp,
  author       = "Robert~B. Parker",
  title        = "The Judas Goat",
  publisher    = "Houghton Mifflin",
  year         = 1978,
  address      = boma,
  keywords     = "terra, london, olympics",
  location     = "PS 3566.A686"
}

@Book{qobemh,
  author       = "Elaine~M. Hayes",
  title        = "Queen of Bebop",
  publisher    = "Ecco",
  year         = 2017,
  address      = nyny,
  keywords     = "sarah vaughan, jazz",
  location     = "ML 420.V3 H39"
}

@Book{prbp1992,
  author       = "Robert~B. Parker",
  title        = "Pastime",
  publisher    = "Berkley Books",
  year         = 1992,
  price        = "$7.99",
  address      = nyny,
  keywords     = "parents and children",
  location     = "PS 3566.A686 P34"
}

@Book{lfcib,
  author       = "Ian Bassingthwaighte",
  title        = "Live from Cairo",
  publisher    = "Scribner",
  year         = 2017,
  address      = nyny,
  keywords     = "displacement, egypt, cairo, revolution",
  location     = "PS 3602.A8492 L59"
}

@Book{ctew,
  author       = "Rubin Fine",
  title        = "Chess the Easy Way",
  publisher    = "David McKay",
  year         = 1942,
  address      = nyny,
  keywords     = "chess",
  location     = "GV 1445 F55"
}

@Book{whhrc,
  author       = "Hillary Rodham Clinton",
  title        = "What Happened",
  publisher    = "Simon \& Schuster",
  year         = 2017,
  address      = nyny,
  keywords     = "2016 election, politics, media",
  location     = "9 781501 175565"
}

@Book{rbmp,
  author       = "Michael Poore",
  title        = "Reincarnation Blues",
  publisher    = "Del Rey",
  year         = 2017,
  address      = nyny,
  keywords     = "reincarnation, death, learning, doing good",
  location     = "PS 3616.O644 R45"
}

@Book{zbb,
  author       = "Bob Berman",
  title        = "Zapped",
  publisher    = "Little, Brown",
  year         = 2017,
  address      = nyny,
  keywords     = "the electromagnetic spectrum",
  location     = "QC 358.5.B47"
}

@Book{gvrk,
  author       = "Rachel Khong",
  title        = "Goodbye, Vitamin",
  publisher    = "Henry Holt",
  year         = 2017,
  address      = nyny,
  keywords     = "alzheimer's, aimlessness",
  location     = "PS 3611.H66 G66"
}

@Book{l30mt,
  author       = "Max Tegmark",
  title        = "Life 3.0",
  publisher    = "Knopf",
  year         = 2017,
  address      = nyny,
  keywords     = "intelligence, artificial intelligence, AGI, cosmology",
  location     = "Q 334.7.T44"
}

@Book{trrmi,
  author       = "Ryan McIlvain",
  title        = "The Radicals",
  publisher    = "Hogarth",
  year         = 2018,
  address      = nyny,
  keywords     = "protest, violent action",
  location     = "PS 3613.C535 R33"
}

@Book{aaatp,
  author       = "Tim Peake",
  title        = "Ask an Astronaut",
  publisher    = "Little, Brown",
  year         = 2017,
  address      = nyny,
  keywords     = "iss, space travel, space walks, ",
  location     = ""
}

@Book{fcje,
  author       = "Jeffrey Eugenides",
  title        = "Fresh Complaint",
  publisher    = "Farrar, Straus, and Giroux",
  year         = 2017,
  address      = nyny,
  keywords     = "escape, travel, parentage, debt, dreams, separation,
    progress, artichokes, theft, duplicity",
  location     = "PS 3555.U4 A6"
}

@Book{twatp,
  author       = "Charles~C. Mann",
  title        = "The Wizard and the Prophet",
  publisher    = "Alfred~A. Knopf",
  year         = 2018,
  address      = nyny,
  keywords     = "ecology, technology, vogt, borlaug, green revolution",
  location     = "GE 56.V64 M36"
}

@Book{capfd,
  author       = "Fyodor Dostoevsky",
  title        = "Crime and Punishment",
  publisher    = "Liveright",
  year         = 2018,
  translator   = "Michael~R. Katz",
  address      = nyny,
  keywords     = "crime, punishment",
  location     = "PG 3326.P7"
}

@Book{rbds,
  title        = "Reconstruction",
  publisher    = "The Library of America",
  year         = 2018,
  editor       = "Brooks~D. Simpson",
  address      = nyny,
  keywords     = "civil war, reconstruction, politics"
}

@Book{sosv,
  author       = "Anna Yen",
  title        = "Sophia of Silicon Valley",
  publisher    = "William Morrow",
  year         = 2018,
  address      = nyny,
  keywords     = "work-life balance, entrepreneurs"
}

@Book{sdd,
  author       = "Deborah Davis",
  title        = "Strapless",
  publisher    = "Tarcher/Penguin",
  year         = 2003,
  address      = nyny,
  keywords     = "virginie amilie avegno gautreau, john singer sargent, paris
    art scene",
  location     = "ND 237.S3 D38"
}

@Book{thtc,
  author       = "T.~C. Boyle",
  title        = "The Harder They Come",
  publisher    = "Ecco",
  year         = 2015,
  address      = nyny,
  price        = "$15.88",
  keywords     = "violence, sovereign citizens, madness",
  location     = ""
}

@Book{ttmjhy,
  author       = "James Harvey Young",
  title        = "The Toadstool Millionaires",
  publisher    = pup,
  year         = 1961,
  address      = prnj,
  keywords     = "patent medicines, folk medicine",
  location     = "RM 671.A1 Y6"
}

@Book{sitg,
  author       = "Nassim Nicholas Taleb",
  title        = "Skin in the Game",
  publisher    = "Random House",
  year         = 2018,
  address      = nyny,
  keywords     = "risk, sociology, vitriol, information asymmetry, intellectuals",
  location     = "HM 1101.T35"
}

@Book{taoipij,
  author       = "Kenny~A. Hunt",
  title        = "The Art of Image Processing in Java",
  publisher    = "A.~K. Peters",
  year         = 2010,
  address      = "Natick, MA",
  keywords     = "optics, human vision, digital images, java, point processing,
    region processing, geometric operations, image printing, image display,
    frequency domain, image compression, morphological image processing",
  location     = "TA 1637.H87"
}

@Book{fpaai,
  author       = "Peter Henderson",
  title        = "Functional Programming:  Application and Implementation",
  publisher    = ph,
  year         = 1980,
  address      = ecnj,
  keywords     = "functions, programs, functional languages, functional
    programs, program representation, program interpretation, imperative
    programs, machine architectures, non-determinism, backtracking, delayed
    evaluation, higher-order functions",
  location     = "QA 76.6"
}

@Book{tpla,
  author       = "Nafkote Tamirat",
  title        = "The Parking Lot Attendant",
  publisher    = "Henry Holt",
  year         = 2018,
  address      = nyny,
  keywords     = "immigrants, duplicity",
  location     = "PS 3620.A67 P37"
}

@Book{aiapjc,
  author       = "Patrick~J. Charles",
  title        = "Armed in America",
  publisher    = "Prometheus Books",
  year         = 2018,
  address      = "Amherst, " # NY,
  keywords     = "firearms, laws and legislation, gun control, constitutional law",
  location     = "KF 3941.C49"
}

@Book{tdplgb,
  author       = "Gilad Bracha",
  title        = "The Dart Programming Language",
  publisher    = aw,
  year         = 2016,
  address      = boma,
  keywords     = "dart, reflection, type systems, object-oriented programming,
    concurrency, futures, mixins, libraries, functions, asyncrony",
  location     = "QA 76.73.D23 B73"
}

@Book{ildck,
  author       = "Chris Kraus",
  title        = "{I} Love Dick",
  publisher    = "Semiotext(e)",
  year         = 2006,
  address      = "Los Angeles, " # CA,
  keywords     = "letters, art damage",
  location     = "PS 3561.R2873 I15 2006a"
}

@Book{desic,
  author       = "Kevin Watkins",
  title        = "Discrete Event Simulation in {C}",
  publisher    = "McGraw-Hill",
  year         = 1993,
  address      = nyny,
  keywords     = "random numbers, modeling",
  location     = "QA 76.73.C15 W39"
}

@InBook{aplftcaibottamm,
  author       = "Dirk Riehle and Heinz Z{\" u}llighoven",
  title        = "Pattern Languages of Programm Design",
  chapter      = "2, {A} Pattern Language for Tool Construction and Integration Based on the Tools and Materials Metaphor",
  publisher    = "Addison-Wesley",
  year         = 1995,
  editor       = "James~O. Coplien and Douglas~C. Schmidt",
  pages        = "9-42",
  address      = rma,
  keywords     = "tool structure, object-oriented design",
  abstract     = "Why do people prefer to use certain software systems and why
    do they have problems using others? What is the quality within certain
    software that makes people soon feel familiar using it and lets them work
    efficiently? We believe that the key to this quality is found in systems
    that allow people to work according to their qualification and needs while
    using their skills and competence.  We have put together many of the things
    which have proved useful in software engineering over the last decades and
    have integrated these methods and techniques into a unifying approach - the
    Tools and Materials Metaphor.  It has guided us and other developers during
    analysis and design and has helped to envision and finally build systems of
    quality.",
  location     = "http://dirkriehle.com/computer-science/research/1994/plop-1994-tools.pdf"
}

@Article{dcmlamfic,
  author       = "Herath, Jayantha and Yamaguchi, Yoshinori and Saito, Nobuo and Yuba, Toshitsugu",
  title        = "Dataflow Computing Models, Languages, and Machines for Intelligence Computations",
  journal      = tse,
  year         = 1988,
  volume       = 14,
  number       = 12,
  pages        = "1805--1828",
  month        = dec,
  keywords     = "architecture, dataflow, functional and logic programming,
    parallel computation, performance analysis, recursion, control flow,
    symbolic computing",
  abstract     = "The authors compare dataflow computing models, languages, and
    dataflow computing machines for numerical and nonnumerical computations.
    The high-level-language-graph transformations that must be performed to
    achieve high performance for numerical and nonnumerical programs executed
    in a dataflow computing environment are described for Lisp, using the DCBL
    transformations.  Some general problems of dataflow computing machines are
    discussed.  Performance evaluation measurements obtained by executing
    benchmark programs in the ETL nonnumerical dataflow computing environment,
    the EM-3, are presented.",
  location     = "https://doi.org/10.1109/32.9065"
}

@Article{lfegaeodtfsra,
  author       = "Selby, Richard~W. and Porter, Adam~A.",
  title        = "Learning from Examples:  Generation and Evaluation of Decision Trees for Software Resource Analysis",
  journal      = tse,
  year         = 1988,
  volume       = 14,
  number       = 12,
  pages        = "1743--1757",
  month        = dec,
  keywords     = "analysis of variance, decision trees, measurement and
    empirical evaluation, learning from examples, machine learning, software
    effort and error analysis, software metrics",
  abstract     = "A general solution method for the automatic generation of 
    decision (or classification) trees is investigated.  The approach is to
    provide insights through in-depth empirical characterization and evaluation
    of decision trees for one problem domain, specifically, that of software
    resource data analysis.  The purpose of the decision trees is to identify
    classes of objects (software modules) that had high development effort,
    i.e.  in the uppermost quartile relative to past data.  Sixteen software
    systems ranging from 3000 to 112000 source lines have been selected for
    analysis from a NASA production environment.  The collection and analysis
    of 74 attributes (or metrics), for over 4700 objects, capture a multitude
    of information about the objects: development effort, faults, changes,
    design style, and implementation style.  A total of 9600 decision trees are
    automatically generated and evaluated.  The analysis focuses on the
    characterization and evaluation of decision tree accuracy, complexity, and
    composition.  The decision trees correctly identified 79.3% of the software
    modules that had high development effort or faults, on the average across
    all 9600 trees.  The decision trees generated from the best parameter
    combinations correctly identified 88.4% of the modules on the average.
    Visualization of the results is emphasized, and sample decision trees are
    included.", 
  location     = "https://doi.org/10.1109/32.9061"
}

@Article{paia,
  author       = "Keith~L. Clark",
  title        = "{PARLOG} and Its Applications",
  journal      = tse,
  year         = 1988,
  volume       = 14,
  number       = 12,
  pages        = "1792--1804",
  month        = dec,
  keywords     = "communicating processes, logic programming applications,
    logic programming languages, object-oriented programming,
    parallel-programming languages, difference lists",
  abstract     = "The key concepts of the parallel logic programming language 
    PARLOG are introduced by comparing the language with Prolog.  Some
    familiarity with Prolog and with the concepts of logic programming is
    assumed.  Two major application areas of PARLOG, systems programming and
    object-oriented programming, are illustrated.  Other applications are
    briefly surveyed.", 
  location     = "https://doi.org/10.1109/32.9064"
}

@Article{fafcmdtg,
  author       = "Dujardin, Eric and Amiel, Eric and Simon, Eric",
  title        = "Fast Algorithms for Compressed Multimethod Dispatch Table Generation",
  journal      = toplas,
  year         = 1998,
  volume       = 20,
  number       = 1,
  pages        = "116--165",
  month        = jan,
  keywords     = "algorithms, language, measurement, performance, dispatch
    tables, late binding, multimethods, optimization, pole types, run-time
    dispatch", 
  abstract     = "The efficiency of dynamic dispatch is a major impediment to
    the adoption of multimethods in object-oriented languages.  In this
    article, we propose a simple multimethod dispatch scheme based on
    compressed dispatch tables.  This scheme is applicable to any
    object-oriented language using a method precedence order that satisfies a
    specific monotonous property (e.g., as Cecil and Dylan) and guarantees that
    dynamic dispatch is performed in constant time, the latter being a major
    requirement for some languages and applications.  We provide efficient
    algorithms to build the dispatch tables, provide their worst-case
    complexity, and demonstrate the effectiveness of our scheme by real
    measurements performed on two large object-oriented applications.  Finally,
    we provide a detailed comparison of our technique with other existing
    techniques.",
  location     = "https://doi.org/10.1145/271510.271521"
}

@Article{icodt,
  author       = "Sreedhar, Vugranam~C. and Gao, Guang~R. and Lee, Yong-Fong",
  title        = "Incremental Computation of Dominator Trees",
  journal      = sigplan # ir95,
  year         = 1993,
  volume       = 30,
  number       = 3,
  pages        = "1--12",
  month        = mar,
  keywords     = "dominator trees, dj-graph, incremental maintenance,
    control-flow graphs",
  abstract     = "Data flow analysis based on an incremental approach may
    require that  the dominator tree be correctly maintained at all times.
    Previous solutions to the problem of incrementally maintaining dominator
    trees were restricted to reducible flowgraphs.  In this paper we present a
    new algorithm for incrementally maintaining the dominator tree of an
    arbitrary flowgraph, either reducible or irreducible, based on a program
    representation called the DJ-graph.  For the case where an edge is
    inserted, our algorithm is also faster than previous approaches (in the
    worst case).  For the deletion case, our algorithm is likely to run fast on
    the average cases.",
  location     = "https://doi.org/10.1145/202530.202531"
}

@Article{atsfjbs,
  author       = "Stata, Raymie and Abadi, Martin",
  title        = "A Type System for {J}ava Bytecode Subroutines",
  journal      = toplas,
  year         = 1999,
  volume       = 21,
  number       = 1,
  pages        = "90--137",
  month        = jan,
  keywords     = "bytecode verification, java, typing rules",
  abstract     = "Java is typically compiled into an intermediate language,
    JVML, that is interpreted by the Java Virtual Machine.  Because mobile JVML
    code is not always trusted, a bytecode verifier enforces static constraints
    that prevent various dynamic errors.  Given the importance of the bytecode
    verifier for security, its current descriptions are inadequate.  This
    article proposes using typing rules to describe the bytecode verifier
    because they are more precise than prose, clearer than code, and easier to
    reason about than either.  JVML has a subroutine construct which is used
    for the compilation of Java's try-finally statement.  Subroutines are a
    major source of complexity for the bytecode verifier because they are not
    obviously last-in/first-out and because they require a kind of
    polymorphism.  Focusing on subroutines, we isolate an interesting, small
    subset of JVML.  We give typing rules for this subset and prove their
    correctness.  Our type system constitutes a sound basis for bytecode
    verification and a rational reconstruction of a delicate part of Sun's
    bytecode verifier.",
  location     = "https://doi.org/10.1145/314602.314606"
}

@Article{a0ailtsdp,
  author       = "Apt, Krzysztof~R. and Brunekreef, Jacob and Partington, Vincent and Schaerf, Andrea",
  title        = "Alma-0: An Imperative Language that Supports Declarative Programming",
  journal      = toplas,
  year         = 1998,
  volume       = 20,
  number       = 5,
  pages        = "1014--1066",
  month        = sep,
  keywords     = "declarative programming, imperative programming, search
    modula 2, backtracking, reversible assignment, language extensions,
    multi-paradigm programming, logic programming",
  abstract     = "We describe a small programming language, called Alma-0, that
    augments the expressive power of imperative programming with a small number
    of features inspired by the logic programming paradigm.  These additions
    encourage declarative programming and make it a more attractive solutions
    for problems involving search.  We illustrate the use of Alma-0 by
    presenting solutions to a number of classical problems, including search,
    STRIPS planning, knapsack, and Eight Queens.  These solutions are
    substantially simpler than their counterparts written in the imperative or
    in the logic programming style and can be used for different purposes
    without any modification.  We also discuss the implementation of Alma-0 and
    an operational, executable, semantics of a large subset of the language.",
  location     = "https://doi.org/10.1145/293677.293679"
}

@Article{tdmiaacs,
  author       = "Stytz, M.~R. and Frieder, G. and Frieder, O.",
  title        = "Three-Dimensional Medical Imaging: Algorithms and Computer Systems",
  journal      = surveys,
  year         = 1991,
  volume       = 23,
  number       = 4,
  pages        = "421--499",
  month        = dec,
  keywords     = "computer graphics, medical imaging, surface rendering,
    three-dimensional imaging, volume rendering, algorithms, surface
    extraction",
  abstract     = "This paper presents an introduction to the field of
    three-dimensional medical imaging.  It presents medical imaging terms and
    concepts, summarizes the basic operations performed in three-dimensional
    medical imaging, and describes sample algorithms for accomplishing these
    operations.  The paper contains a synopsis of the architectures and
    algorithms used in eight machines to render three-dimensional medical
    images, with particular emphasis paid to their distinctive contributions.
    It compares the performance of the machines along several dimensions,
    including image resolution, elapsed time to form an image, imaging
    algorithms used in the machine, and the degree of parallelism used in the
    architecture.  The paper concludes with general trends for future
    developments in this field and references on three-dimensional medical
    imaging.",
  location     = "https://doi.org/10.1145/125137.125155"
}

@Article{ehipi,
  author       = "M.~Donald MacLaren",
  title        = "Exception Handling in {PL}/{I}",
  journal      = sigplan # " (" # pot # "ACM Conference on Language Design for Reliable Software)",
  year         = 1977,
  volume       = 12,
  number       = 3,
  pages        = "101--104",
  month        = mar,
  keywords     = "pl/1, exceptional conditions, errors, interrupts, non-local
    go-tos, structured programming, code generation",
  abstract     = "The PL/I language's facilities for handling exceptional
    conditions are analyzed.  The description is based on the new PL/I
    standard.  Special attention is given to fine points which are not well
    known.  The analysis is generally critical.  It emphasizes problems in
    regards to implementation and structured programming.  A few suggestions
    for future language design are offered.",
  location     = "https://doi.org/10.1145/390017.808316"
}

@Article{wwwtiu,
  author       = "Tim Berners-Lee and Robert Cailliau and Jean-Fran{\c c}ois Groff and Bernd Pollermann",
  title        = "{W}orld-{W}ide {W}eb: The Information Universe",
  journal      = "Electronic Networking: Research, Applications and Policy",
  year         = 1992,
  volume       = 1,
  number       = 2,
  pages        = "74--82",
  month        = "Spring",
  keywords     = "information access, hypertext, document management",
  abstract     = {The World-Wide Web (W3) initiative is a practical project to
    bring a global information universe into existence using available
    technology.  This article describes the aims, data model, and protocols
    needed to implement the "web," and compares them with various contemporary
    systems.},
  location     = "www.w3.org/History/1992/ENRAP/Article_9202.txt"
}

@Article{apaffafhol,
  author       = "Ashley, J.~Michael and Dybvig, R.~Kent",
  title        = "{A} Practical and Flexible Flow Analysis for Higher-Order Languages",
  journal      = toplas,
  year         = 1998,
  volume       = 20,
  number       = 4,
  pages        = "845--868",
  month        = jul,
  keywords     = "abstract interpretation, higher-order languages, compiler
      optimizations, closures, scheme, flow analysis, data analysis",
  abstract     = "A flow analysis collects data-flow and control-flow
      information about programs.  A compiler can use this information to
      enable optimizations.  The analysis described in this article unifies and
      extends previous work on flow analysis for higher-order languages
      supporting assignment and control operators.  The analysis is abstract
      interpretation based and is parameterized over two polyvariance operators
      and a projection operator.  These operators are used to regulate the
      speed and accuracy of the analysis.  An implementation of the analysis is
      incorporated into and used in a production Scheme compiler.  The analysis
      can process any legal Scheme program without modification.  Others have
      demonstrated that a 0CFA analysis can enables the optimizations, but a
      0CFA analysis is O(n)3).  An O(n) instantiation of our analysis
      successfully enables the optimization of closure representations and
      procedure calls.  Experiments with the cheaper instantiation show that it
      is as effective as 0CFA for these optimizations.",
  location     = "https://doi.org/10.1145/291891.291898"
}

@Article{dokbswakba,
  author       = "Schoen, Eric and Smith, Reid~G. and Buchanan, Bruce~G.",
  title        = "Design of Knowledge-Based Systems with a Knowledge-Based Assistant",
  journal      = tse,
  year         = 1988,
  volume       = 14,
  number       = 12,
  pages        = "1771--1791",
  month        = dec,
  keywords     = "knowledge acquisition, knowledge-based systems,
    object-oriented programming, structured editing, programming environments,
    user interfaces",
  abstract     = "The authors propose a model for an intelligent assistant to
    aid in building knowledge-based systems (KBSs) and discuss a preliminary
    implementation.  The assistant participates in KBS construction, including
    acquisition of an initial model of a problem domain, acquisition of control
    and task-specific inference knowledge, testing and validation, and
    long-term maintenance of encoded knowledge.  The authors present a
    hypothetical scenario in which the assistant and a KBS designer cooperate
    to create an initial domain model and then discuss five categories of
    knowledge the assistant requires to offer such help.  They discuss two
    software technologies on which the assistant is based: an object-oriented
    programming language, and a user-interface framework.",
  location     = "https://doi.org/10.1109/32.9063"
}

@Article{hslanatpas,
  author       = "Abeysundara, Bandula~W. and Kamal, Ahmed~E.",
  title        = "High-Speed Local Area Networks and Their Performance:  {A} Survey",
  journal      = surveys,
  year         = 1991,
  volume       = 23,
  number       = 2,
  pages        = "221--264",
  month        = jun,
  keywords     = "access schemes, computer networks, data communication, medium
    access protocols, optical fiber networks, simulation, bus networks, ring
    networks, tree networks",
  abstract     = "At high data transmission rates, the packet transmission time
    of a local  area network (LAN) could become comparable to or less than the
    medium propagation delay.  The performance of many LAN schemes degrades
    rapidly when the packet transmission time becomes small comparative to the
    medium propagation delay.  This paper introduces LANs and discusses the
    performance degradation of LANs at high speeds.  It surveys recently
    proposed LAN schemes designed to operate at high data rates, including
    their performance characteristics desirable in LAN medium access protocols
    are identified and discussed.  The paper serves as a tutorial for readers
    less familiar with local computer communication networks.  It also serves
    as a survey of the state-of-the-art LANs.",
  location     = "https://doi.org/10.1145/103724.103726"
}

@Article{srtropeh,
  author       = "Melliar-Smith, P.~M. and Randell, B.",
  title        = "Software Reliability: The Role of Programmed Exception Handling",
  journal      = sigplan # " (" # pot # "ACM Conference on Language Design for Reliable Software)",
  year         = 1977,
  volume       = 12,
  number       = 3,
  pages        = "95--100",
  month        = mar,
  keywords     = "failures, errors, faults, exceptions, recovery blocks,
    failure handling, reliable software design",
  abstract     = "The paper discusses the basic concepts underlying the issue
    of software reliability, and argues that programmed exception handling is
    inappropriate for dealing with suspected software errors.  Instead it is
    shown, using an example program, how exception handling can be combined
    with the recovery block structure.  The result is to improve the
    effectiveness with which problems due to anticipated faulty input data,
    hardware components, etc., are dealt with, while continuing to provide
    means for recovering from unanticipated faults, including ones due to
    residual software design errors.", 
  location     = "https://doi.org/10.1145/390018.808315"
}

@Article{acotwapi,
  author       = "Diomidis Spinellis",
  title        = "{A} Critique of the {W}indows Application Programming Interface",
  journal      = "Computer Standards \& Interfaces",
  year         = 1993,
  volume       = 20,
  number       = 1,
  pages        = "1--8",
  month        = nov,
  keywords     = "function names, naming conventions, portability, type
    systems, name-space pollution",
  abstract     = "The architecture, interface, and functionality of the Windows
    Application Programming Interface (API) make it difficult to master and use
    effectively, and contribute negatively to the safety, robustness, and
    portability of the applications developed under it.  The API is structured
    around a large and constantly evolving set of functions and is based on a
    problematic shared library implementation.  The provided interfaces are
    complicated, nonorthogonal, abuse the type system, cause name-space
    pollution, and use inconsistent naming conventions.  In addition, the
    functionality of the interface suffers from inconsistency, incompleteness,
    and inadequate documentation.  Application developers, programming tool
    vendors, and Microsoft should face the above problems and provide
    appropriate solutions.", 
  location     = "https://doi.org/10.1016/S0920-5489%2898%2900012-9"
}

@Article{aaefeis,
  author       = "Erman, Lee~D. and Lark, Jay~S. and Hayes-Roth, Frederick",
  title        = "{ABE}:  An Environment for Engineering Intelligent Systems",
  journal      = tse,
  year         = 1993,
  volume       = 14,
  number       = 12,
  pages        = "1758--1770",
  month        = dec,
  keywords     = "cooperative operating system, distributed computing,
    intelligent-systems engineering, module-oriented programming, layered
    architecture, abstract machines",
  abstract     = "The ABE multilevel architecture for developing intelligent
    systems addresses the key problems of intelligent systems engineering:
    large-scale applications and the reuse and integration of software
    components.  ABE defines a virtual machine for module-oriented programming
    and a cooperative operating system that provides access to the capabilities
    of that virtual machine.  On top of the virtual machine, ABE provides a
    number of systemdesign and development frameworks, which embody such
    programming metaphors as control flow, blackboards, and dataflow.  These
    frameworks support the construction of capabilities, including knowledge
    processing tools, which span a range from primitive modules to skeletal
    systems.  Finally, applications can be built on skeletal systems.  In
    addition, ABE supports the importation of existing software, including both
    conventional and knowledge processing tools.",
  location     = "https://doi.org/10.1109/32.9062"
}

@Article{calwdt,
  author       = "Augustsson, Lennart",
  title        = "Cayenne --- {A} Language with Dependent Types",
  journal      = sigplan,
  year         = 1999,
  volume       = 34,
  number       = 1,
  pages        = "239--250",
  month        = jan,
  keywords     = "type systems, language design, dependent types, module systems",
  abstract     = "Cayenne is a Haskell-like language.  The main difference
    between Haskell and Cayenne is that Cayenne has dependent types, i.e., the
    result type of a function may depend on the argument value, and types of
    record components (which can be types or values) may depend on other
    components.  Cayenne also combines the syntactic categories for value
    expressions and type expressions; thus reducing the number of language
    concepts.Having dependent types and combined type and value expressions
    makes the language very powerful.  It is powerful enough that a special
    module concept is unnecessary; ordinary records suffice.  It is also
    powerful enough to encode predicate logic at the type level, allowing types
    to be used as specifications of programs.  However, this power comes at a
    cost: type checking of Cayenne is undecidable.  While this may appear to be
    a steep price to pay, it seems to work well in practice.", 
  location     = "https://doi.org/10.1145/291251.289451"
}

@Article{iomad,
  author       = "Litwin, Witold and Mark, Leo and Roussopoulos, Nick",
  title        = "Interoperability of Multiple Autonomous Databases",
  journal      = surveys,
  year         = 1990,
  volume       = 22,
  number       = 3,
  pages        = "267--293",
  month        = sep,
  keywords     = "database autonomy, database interoperability without global
    schema, distributed databases, federated databases, multidatabases,
    multidatabase language",
  abstract     = "Database systems were a solution to the problem of shared
    access to heterogeneous files created by multiple autonomous applications
    in a centralized environment.  To make data usage easier, the files were
    replaced by a globally integrated database.  To a large extent, the idea
    was successful, and many databases are now accessible through local and
    long-haul networks.  Unavoidably, users now need shared access to multiple
    autonomous databases.  The question is what the corresponding methodology
    should be.  Should one reapply the database approach to create globally
    integrated distributed database systems or should a new approach be
    introduced? We argue for a new approach to solving such data management
    system problems, called multidatabase or federated systems.  These systems
    make databases interoperable, that is, usable without a globally integrated
    schema.  They preserve the autonomy of each database yet support shared
    access.  Systems of this type will be of major importance in the future.
    This paper first discusses why this is the case.  Then, it presents
    methodologies for their design.  It further shows that major commerical
    relational database systems are evolving toward multidatabase systems.  The
    paper discusses their capabilities and limitations, presents and discusses
    a set of prototypes, and, finally, presents some current research issues.", 
  location     = "https://doi.org/10.1145/96602.96608"
}

@Article{bsansa,
  author       = "Joshua~J. Arulanandham and Cristian~S. Calude and Michael~J. Dinneen",
  title        = "Bead–Sort: {A} Natural Sorting Algorithm",
  journal      = "The Bulletin of the European Association for Theoretical Computer Science",
  year         = 2002,
  volume       = 76,
  pages        = "153--162",
  keywords     = "sorting, linear sorts, sorting implementations",
  abstract     = "Nature is not only a source of minerals and precious stones
    but is also a mine of algorithms.  By observing and studying natural
    phenomena, computer algorithms can be extracted.  In this note, a simple
    natural phenomenon is used to design a sorting algorithm for positive
    integers, called here Bead-Sort.  The algorithm's run-time complexity
    ranges from O(1) to O(S) (S is the sum of the input integers) depending on
    the user's perspective.  Finally, three possible implementations are
    suggested.",
  location     = "https://www.cs.auckland.ac.nz/~mjd/misc/BeadSort5.pdf"
}

@Article{cois,
  author       = "Anish Arora and Paul Attie and Michael Evangelist and Mohamed Gouda",
  title        = "Convergence of Iteration Systems",
  journal      = "Distributed Computing",
  year         = 1993,
  volume       = 7,
  number       = 1,
  pages        = "43--53",
  month        = nov,
  keywords     = "convergence, stabilization, iteration systems, dependency graph",
  abstract     = "An iteration system is a set of assignment statements whose
    computation proceeds in steps: at each step, an arbitrary subset of the
    statements is executed in parallel.  The set of statements thus executed
    may differ at each step; however, it is required that each statement is
    executed infinitely often along the computation.  The convergence of such
    systems (to a fixed point) is typically verified by showing that the value
    of a given variant function is decreased by each step that causes a state
    change.  Such a proof requires an exponential number of cases (in the
    number of assignment statements) to be considered.  In this paper, we
    present alternative methods for verifying the convergence of iteration
    systems.  In most of these methods, upto a linear number of cases need to
    be considered.",
  location     = "https://doi.org/10.1007/BF02278855"
}

@Article{ttipl,
  author       = "Herriot, Robert~G.",
  title        = "Towards the Ideal Programming Language",
  journal      = sigplan # " (" # pot # "ACM Conference on Language Design for Reliable Software)",
  year         = 1977,
  volume       = 12,
  number       = 3,
  pages        = "56--62",
  month        = mar,
  keywords     = "types, simula class, instances, pascal, adjectives,
    modifiers, procedures, extensible languages, plasma, smalltalk, prepositions,
    imperative operators, applicative operators, which operator, passive operator",
  abstract     = "A programming language with good features and notation can
    help the programmer represent his abstractions in the programming language,
    and can also help someone else understand the original abstraction.  There
    have been numerous proposals for better features.  In this paper we propose
    several new ideas to improve the notation.  First we suggest that class
    instances be named with a sequence of identifiers consisting of the class
    name preceded by modifiers.  Then we propose that prepositions be placed
    before procedure parameters to suggest their role.  Finally, we suggest
    that applicative and imperative operations can be separated semantically,
    and then recombined syntactically through the use of the which and passive
    operators.",
  location     = "https://doi.org/10.1145/390017.808311"
}

@Article{assofli,
  author       = "Douence, R{\' e}mi and Fradet, Pascal",
  title        = "{A} Systematic Study of Functional Language Implementations",
  journal      = toplas,
  year         = 1998,
  volume       = 20,
  number       = 2,
  pages        = "344--387",
  month        = mar,
  keywords     = "abstract machines, compilers, combinators, functional
    programming, program transformation, comparative implementations",
  abstract     = "We introduce a unified framework to describe, relate,
    compare, and classify functional language implementations.  The compilation
    process is expressed as a succession of program transformations in the
    common framework.  At each step, different transformations model
    fundamental choices.  A benefit of this approach is to structure and
    decompose the implementation process.  The correctness proofs can be
    tackled independently for each step and amount to proving program
    transformations in the functional world.  This approach also paves the way
    to formal comparisons by making it possible to estimate the complexity of
    individual transformations or compositions of them.  Our study aims at
    covering the whole known design space of sequential functional language
    implementations.  In particular, we consider call-by-value, call-by-name,
    call-by-need reduction strategies as well as environment- and graph-based
    implementations.  We describe for each compilation step the diverse
    alternatives as program transformations.  In some cases, we illustrate how
    to compare or relate compilation techniques, express global optimizations,
    or hybrid implementations.  We also provide a classification of well-known
    abstract machines.", 
  location     = "https://doi.org/10.1145/276393.276397"
}

@Article{dobps,
  author       = "Chin, Roger~S. and Chanson, Samuel~T.",
  title        = "Distributed Object-Based Programming Systems",
  journal      = surveys,
  year         = 1991,
  volume       = 23,
  number       = 1,
  pages        = "91--124",
  month        = mar,
  keywords     = "capabilities, distributed operating systems, error recovery,
    method invocation, nested transactions, object-based programming languages,
    object model, object reliability, processor allocation, resource management,
    synchronization, transactions",
  abstract     = "The development of distributed operating systems and
    object-based programming languages makes possible an environment in which
    programs consisting of a set of interacting modules, or objects, may
    execute concurrently on a collection of loosely coupled processors.  An
    object-based programming language encourages a methodology for designing
    and creating a program as a set of autonomous components, whereas a
    distributed operating system permits a collection of workstations or
    personal computers to be treated as a single entity.  The amalgamation of
    these two concepts has resulted in systems that shall be referred to as
    distributed, object-based programming systems.  This paper discusses issues
    in the design and implementation of such systems.  Following the
    presentation of fundamental concepts and various object models, issues in
    object management, object interaction management, and physical resource
    management are discussed.  Extensive examples are drawn from existing
    systems.", 
  location     = "https://doi.org/10.1145/103162.103165"
}

@Article{setas,
  author       = "Guttag, Jhon~V. and Horowitz, Ellis and Musser, David~R.",
  title        = "Some Extensions to Algebraic Specifications",
  journal      = sigplan # " (" # pot # "ACM Conference on Language Design for Reliable Software)",
  year         = 1977,
  volume       = 12,
  number       = 3,
  pages        = "62--67",
  month        = mar,
  keywords     = "abstract data type, data structures, programming languages,
    procedure specification, error specification, correctness, functional
    programming",
  abstract     = "Algebraic specifications of abstract data types are beginning
    to gain wide currency.  In this paper we discuss an extension to this
    specification technique which allows the specification of procedures which
    alter their parameters, and various ways of handling the specification of
    error conditions.",
  location     = "https://doi.org/10.1145/800022.808312"
}

@Article{rdtsaeoipov,
  author       = "Buckle, Normand",
  title        = "Restricted Data Types, Specification and Enforcement of Invariant Properties of Variables",
  journal      = sigplan # " (" # pot # "ACM Conference on Language Design for Reliable Software)",
  year         = 1977,
  volume       = 12,
  number       = 3,
  pages        = "68--76",
  month        = mar,
  keywords     = "data type, invariant property, programming language,
    readability, reliability, restricted type, runtime verification, type checking",
  abstract     = "When defining a data type, it is often useful to specify
    restrictions on the permitted values of that type.  Pascal's subrange type
    declaration, a special case of this kind of constraint definition, has
    already proved itself to be quite useful.  Restricted data types allow more
    complex constraints to be defined and checked; for example, a variable
    could be declared of type odd integer or the day field of a
    date type variable could be checked for consistency with the
    year and month fields.  A simple mechanism is proposed, allowing the
    formulation of such constraints and their association with data types; the
    behaviour of a restricted type variable is described.  The effects of the
    use of such a mechanism on program reliability, readability and efficiency
    are discussed.", 
  location     = "https://doi.org/10.1145/800022.808313"
}

@Article{olsicm,
  author       = "Anger, Frank~D.",
  title        = "On {L}amport's Interprocessor Communication Model",
  journal      = toplas,
  year         = 1989,
  volume       = 11,
  number       = 3,
  pages        = "404--417",
  month        = jul,
  keywords     = "nonatomic operations, abstractions, axiom schemes",
  abstract     = "Leslie Lamport presented a set of axioms in 1979 that capture
    the essential properties of the temporal relationships between complex and
    perhaps unspecified activities within any system, and proceeded to use this
    axiom system to prove the correctness of sophisticated algorithms for
    reliable communication and mutual exclusion in systems without shared
    memory.  As a step toward a more complete metatheory of Lamport's axiom
    system, this paper determines the extent to which that system differs from
    systems based on atomic or indivisible, actions.  Theorem 1 shows that only
    very weak conditions need be satisfied in addition to the given axioms to
    guarantee the existence of an atomic model while Proposition 1 gives
    sufficient conditions under which any such model must be a faithful
    representation.  Finally, Theorem 2 restates a result of Lamport showing
    exactly when a system can be thought of as made up of a set of atomic
    events that can be totally ordered temporally.  A new constructive proof is
    offered for this result.", 
  location     = "https://doi.org/10.1145/65979.65982"
}

@Article{iftsutsmaat,
  author       = "Schneider, Fred~B.",
  title        = "Implementing Fault-Tolerant Services Using the State Machine Approach: {A} Tutorial",
  journal      = surveys,
  year         = 1990,
  volume       = 22,
  number       = 4,
  pages        = "299--319",
  month        = dec,
  keywords     = "client-server, distributed services, state machines,
    fail-stop processors, byzantine failures", 
  abstract     = "The state machine approach is a general method for
    implementing fault-tolerant services in distributed systems.  This paper
    reviews the approach and describes protocols for two different failure
    models&mdash;Byzantine and fail stop.  Systems reconfiguration techniques
    for removing faulty components and integrating repaired components are also
    discussed.",
  location     = "https://doi.org/10.1145/98163.98167"
}

@Article{ascwfacadpl,
  author       = "Corrodi, Claudio and Heu{\ss}ner, Alexander and Poskitt, Christopher~M.",
  title        = "{A} Semantics Comparison Workbench for a Concurrent, Asynchronous, Distributed Programming Language",
  journal      = "Formal Aspects of Computing",
  year         = 2018,
  volume       = 30,
  number       = 1,
  pages        = "163--192",
  month        = jan,
  keywords     = "concurrent asynchronous programming, distributed programming
    with message passing, operational semantics, runtime semantics, graph
    transformation systems, verification/analysis parameterised by semantics,
    concurrency abstractions, object-oriented programming, software engineering,
    scoop, groove",
  abstract     = "A number of high-level languages and libraries have been
    proposed that offer novel and simple to use abstractions for concurrent,
    asynchronous, and distributed programming.  The execution models that
    realise them, however, often change over time--whether to improve
    performance, or to extend them to new language features--potentially
    affecting behavioural and safety properties of existing programs.  This is
    exemplified by Scoop, a message-passing approach to concurrent
    object-oriented programming that has seen multiple changes proposed and
    implemented, with demonstrable consequences for an idiomatic usage of its
    core abstraction.  We propose a semantics comparison workbench for Scoop
    with fully and semi-automatic tools for analysing and comparing the state
    spaces of programs with respect to different execution models or semantics.
    We demonstrate its use in checking the consistency of properties across
    semantics by applying it to a set of representative programs, and
    highlighting a deadlock-related discrepancy between the principal execution
    models of Scoop.  Furthermore, we demonstrate the extensibility of the
    workbench by generalising the formalisation of an execution model to
    support recently proposed extensions for distributed programming.  Our
    workbench is based on a modular and parameterisable graph transformation
    semantics implemented in the Groove tool.  We discuss how graph
    transformations are leveraged to atomically model intricate language
    abstractions, how the visual yet algebraic nature of the model can be used
    to ascertain soundness, and highlight how the approach could be applied to
    similar languages.", 
  location     = "https://doi.org/10.1007/s00165-017-0443-1"
}

@Article{aifssh,
  author       = "Serpette, Bernard~P. and Serrano, Manuel",
  title        = "An Interpreter for Server-Side {H}op",
  journal      = sigplan # " (" # pot # "Seventh Symposium on Dynamic Languages)",
  year         = 2012,
  volume       = 47,
  number       = 2,
  pages        = "1--12",
  month        = feb,
  keywords     = "functional languages, scheme, interpreter implementation,
    threaded code, optimizations",
  abstract     = "HOP is a Scheme-based multi-tier programming language for the
    Web. The client-side of a program is compiled to JavaScript, while the
    server-side is executed by a mix of natively compiled code and interpreted
    code.  At the time where HOP programs were basic scripts, the performance
    of the server-side interpreter was not a concern; an inefficient
    interpreter was acceptable.  As HOP expanded, HOP programs got larger and
    more complex.  A more efficient interpreter was necessary.  This new
    interpreter is described in this paper.  It is compact, its whole
    implementation counting no more than 2.5 KLOC.  It is more than twice
    faster than the old interpreter and consumes less than a third of its
    memory.  Although it cannot compete with static or JIT native compilers,
    our experimental results show that it is amongst the fastest interpreters
    for dynamic languages.",
  location     = "https://doi.org/10.1145/2168696.2047851"
}

@Article{hatjcfp,
  author       = "Homescu, Andrei and {\c S}uhan, Alex",
  title        = "HappyJIT:  A Tracing {JIT} Compiler for {PHP}",
  journal      = sigplan # " (" # pot # "Seventh Symposium on Dynamic Languages)",
  year         = 2012,
  volume       = 47,
  number       = 2,
  pages        = "25--36",
  month        = feb,
  keywords     = "php, jit compilation, interpretation, pypy, tracing,
    optimization, dynamic typing",
  abstract     = "Current websites are a combination of server-generated
    dynamic content with client-side interactive programs.  Dynamically - typed
    languages have gained a lot of ground in both of these domains.  The growth
    of Web 2.0 has introduced a myriad of websites which contain personalized
    content, which is specific to the user.  PHP or Python programs generate
    the actual HTML page after querying a database and processing the results,
    which are then presented by the browser.  It is becoming more and more
    vital to accelerate the execution of these programs, as this is a
    significant part of the total time needed to present the page to the user.
    This paper presents a novel interpreter for the PHP language written in
    RPython, which the PyPy translator then translates into C.  The translator
    integrates into the interpreter a tracing just-in-time compiler which
    optimizes the hottest loops in the interpreted programs.  We also describe
    a data model that supports all the data types in the PHP language, such as
    references and iterators.  We evaluate the performance of this interpreter,
    showing that speedups up to a factor of 8 are observed using this
    approach.", 
  location     = "https://doi.org/10.1145/2047849.2047854"
}

@Article{tgua,
  author       = "Brown, C.~Wayne",
  title        = "Teaching Graphics Using {A}da",
  journal      = "Ada Newsletter (" # pot # "2004 Annual ACM SIGAda International Conference on Ada)",
  year         = 2004,
  volume       = 24,
  number       = 4,
  pages        = "47--50",
  month        = dec,
  keywords     = "graphics, ada, ",
  abstract     = "This paper describes several Ada-language tools supporting a
    computer-graphics course.  These tools include an updated and improved
    OpenGL Ada specification file, a VRML-to-code conversion tool, and an
    Ada-to-C conversion tool.  The tool-development rational and some
    implementation issues are discussed.",
  location     = "https://doi.org/10.1145/1032297.1032306"
}

@Article{aoapffs,
  author       = "Friedman, Daniel~P. and Wise, David~S.",
  title        = "Aspects of Applicative Programming for File Systems",
  journal      = osr # " (" # pot # "ACM Conference on Language Design for Reliable Software)",
  year         = 1977,
  volume       = 11,
  number       = 2,
  pages        = "41--55",
  month        = apr,
  keywords     = "referential transparency, recursive programming, real time,
    shared file, functional combination, suspension, text editor, lazy
    evaluation",
  abstract     = "This paper develops the implications of recent results in
    semantics for applicative programming.  Applying suspended evaluation
    (call-by-need) to the arguments of file construction functions results in
    an implicit synchronization of computation and output.  The programmer need
    not participate in the determination of the pace and the extent of the
    evaluation of his program.  Problems concerning multiple input and multiple
    output files are considered: typical behavior is illustrated with an
    example of a rudimentary text editor written applicatively.  As shown in
    the trace of this program, the driver of the program is the sequential
    output device(s).  Implications of applicative languages for I/O bound
    operating systems are briefly considered.", 
  location     = "https://doi.org/10.1145/390018.808310"
}

@Article{ceaaofpl,
  author       = "Paul Hudak",
  title        = "Conception, Evolution, and Application of Functional Programming Languages",
  journal      = surveys,
  year         = 1989,
  volume       = 21,
  number       = 3,
  pages        = "359--411",
  month        = sep,
  keywords     = "data abstraction, higher-order functions, lazy evaluation,
    referential transparency, types, lambda calculus, language design, lisp,
    haskell, pattern matching, functional i-o", 
  abstract     = "The foundations of functional programming languages are
    examined from both historical and technical perspectives.  Their evolution
    is traced through several critical periods: early work on lambda calculus
    and combinatory calculus, Lisp, Iswim, FP, ML, and modern functional
    languages such as Miranda1 and Haskell.  The fundamental premises on which
    the functional programming methodology stands are critically analyzed with
    respect to philosophical, theoretical, and pragmatic concerns.  Particular
    attention is paid to the main features that characterize modern functional
    languages: higher-order functions, lazy evaluation, equations and pattern
    matching, strong static typing and type inference, and data abstraction.
    In addition, current research areas&mdash;such as parallelism,
    nondeterminism, input/output, and state-oriented computations&mdash;are
    examined with the goal of predicting the future development and application
    of functional languages.",
  location     = "https://doi.org/10.1145/72551.72554"
}

@Article{wsatframp,
  author       = "Maggiolo-Schettini, Andrea. and Napoli, Margherita and Tortora, Genoveffa",
  title        = "Web Structures:  {A} Tool for Representing and Manipulating Programs",
  journal      = tse,
  year         = 1988,
  volume       = 14,
  number       = 11,
  pages        = "1621--1639",
  month        = nov,
  keywords     = "data flow analysis, high level program transformations,
    interpretive semantics, programming languages, replacement systems,
    category theory, web structures, macroderivations",
  abstract     = "The authors introduce web structures and their
    transformations and develop their theory in the framework of category
    theory.  Once a program has been represented as a web structure, software
    tools, such as a high-level data flow analyzer or other general program
    transformers, can be written as sets of web structure production rules.  An
    implementation of web structure transformations is in progress.  The
    mathematical theory of web structure transformations allows form proofs of
    properties both at the metatheoretical and theoretical levels.", 
  location     = "https://doi.org/10.1109/32.9050"
}

@Article{shsirl,
  author       = "Waldvogel, Marcel and Varghese, George and Turner, Jon and Plattner, Bernhard",
  title        = "Scalable High Speed {IP} Routing Lookups",
  journal      = ccr # " (" # pot # "ACM SIGCOMM '97 Conference on Applications, Technologies, Architectures, and Protocols for Computer Communication)",
  year         = 1997,
  volume       = 27,
  number       = 4,
  pages        = "25--36",
  month        = oct,
  keywords     = "binary search, hash tables, ip lookup, backtracking,
    precomputation, rope search",
  abstract     = "Internet address lookup is a challenging problem because of
    increasing routing table sizes, increased traffic, higher speed links, and
    the migration to 128 bit IPv6 addresses.  IP routing lookup requires
    computing the best matching prefix, for which standard solutions like
    hashing were believed to be inapplicable.  The best existing solution we
    know of, BSD radix tries, scales badly as IP moves to 128 bit addresses.
    Our paper describes a new algorithm for best matching prefix using binary
    search on hash tables organized by prefix lengths.  Our scheme scales very
    well as address and routing table sizes increase: independent of the table
    size, it requires a worst case time of log2(address bits) hash lookups.
    Thus only 5 hash lookups are needed for IPv4 and 7 for IPv6.  We also
    introduce Mutating Binary Search and other optimizations that, for a
    typical IPv4 backbone router with over 33,000 entries, considerably reduce
    the average number of hashes to less than 2, of which one hash can be
    simplified to an indexed array access.  We expect similar average case
    behavior for IPv6.", 
  location     = "https://doi.org/10.1145/263109.263136"
}

@Article{ptttm,
  author       = "John Vissides",
  title        = "Patterns: The Top Ten Misconceptions",
  journal      = "Object Magazine",
  year         = 1997,
  volume       = 7,
  number       = 1,
  pages        = "30--33",
  keywords     = "context",
  location     = "http://www.research.ibm.com/designpatterns/pubs/top10misc.html"
}

@Article{mipp,
  author       = "Charles Tilly",
  title        = "Mechanisms in Political Processes",
  journal      = "Annual Review of Political Science",
  year         = 2001,
  volume       = 4,
  pages        = "21--41",
  keywords     = "public politics, democratization, trust networks, inequality,
    regime environment, change mechanisms",
  abstract     = "Ostensibly theoretical disputes in political science often
    involve competing approaches to explanation, including skepticism, covering
    law arguments, reconstructions of propensities, system models, and
    explanations featuring causal mechanisms.  Mechanism- and process-based
    accounts, including cognitive, environmental, and relational effects,
    deserve more attention than they have received in recent political science.
    Analyses of democratization illustrate these points.",
  location     = "https://doi.org/10.1146/annurev.polisci.4.1.21"
}

@Article{icfaofopwtco,
  author       = "Debray, Saumya~K. and Proebsting, Todd~A.",
  title        = "Interprocedural Control Flow Analysis of First-Order Programs with Tail-Call Optimization",
  journal      = toplas,
  year         = 1997,
  volume       = 19,
  number       = 4,
  pages        = "568--585",
  month        = jul,
  keywords     = "control-flow analysis, interprocedural analysis, control-flow
    grammars, follow sets, lr(0) parsers, lr(1) parsers, ",
  abstract     = "Knowledge of low-level control flow is essential for many
    compiler optimizations.  In systems with tail-call optimization, the
    determination of interprocedural control flow is complicated by the fact
    that because of tail-call optimization, control flow at procedure returns
    is not readily evident from the call graph of the program.  This article
    shows how interprocedural control-flow analysis of first-order programs can
    be carried out using well-known concepts from parsing theory.  In
    particular, we show that context-insensitive ( or zeroth-order)
    control-flow analysis corresponds to the notion of FOLLOW sets in
    context-free grammars, while context-sensitive (or first-order)
    control-flow analysis corresponds to the notion of LR(1) items.  The
    control-flow information so obtained can be used to improve the precision
    of interprocedural dataflow analyses as well as to extend certain low-level
    code optimizations across procedure boundaries.", 
  location     = "https://doi.org/10.1145/262004.262006"
}

@Article{tladomsl,
  author       = "Ilkka Toumi",
  title        = "The Lives and Death of {M}oore's Law",
  journal      = "First Monday",
  year         = 2002,
  volume       = 7,
  number       = 11,
  month        = nov,
  keywords     = "transistor counts, hardware development",
  abstract     = "Moore’s Law has been an important benchmark for developments
    in microelectronics and information processing for over three decades.
    During this time, its applications and interpretations have proliferated
    and expanded, often far beyond the validity of the original assumptions
    made by Moore.  Technical considerations of optimal chip manufacturing
    costs have been expanded to processor performance, economics of computing,
    and social development.  It is therefore useful to review the various
    interpretations of Moore’s Law and empirical evidence that could support
    them.  Such an analysis reveals that semiconductor technology has evolved
    during the last four decades under very special economic conditions.  In
    particular, the rapid development of microelectronics implies that economic
    and social demand has played a limited role in this industry.  Contrary to
    popular claims, it appears that the common versions of Moore’s Law have not
    been valid during the last decades.  As semiconductors are becoming
    important in economy and society, Moore’s Law is now becoming an
    increasingly misleading predictor of future developments.", 
  location     = "http://firstmonday.org/ojs/index.php/fm/article/view/1000/921"
}

@Article{lslcw,
  author       = "Clark Williams",
  title        = "Linux Scheduler Latency",
  journal      = "EE Times",
  year         = 2002,
  month        = jun,
  keywords     = "latency, response time, interrupts, preemption",
  abstract     = "One of my jobs at Red Hat is to evaluate and recommend new
    techniques for embedded Linux solutions.  Scheduler latency is one of the
    biggest complaints that hard realtime champions have about Linux.  I
    decided to evaluate preemption and low-latency to see which one came out on
    top.",
  location     = "https://www.eetimes.com/document.asp?doc_id=1200916"
}

@Article{twtmsyppsdtmolb,
  author       = "Gregory~V. Wilson and Brent Gorda and Paul Lu",
  title        = "Twelve Ways to Make Sure Your Parallel Programming System Doesn't Make Others Look Bad",
  journal      = ieeec,
  year         = 1994,
  volume       = 27,
  number       = 10,
  pages        = 112,
  month        = oct,
  keywords     = "group operations, i-o, marshaling, timesharing, behavior, performance",
  abstract     = "Anyone who has done any parallel programming knows that it's
    more difficult than sequential programming.  To keep ourselves employed, we
    should make sure it stays that way.  Therefore, if you're adding to the
    hundreds of parallel programming systems in existence, please follow these
    rules so that your system won't make the rest of us look stupid.",
  location     = "TK 7885.A1 I15X"
}

@Article{affnps,
  author       = "H{\" u}ni, Hermann and Johnson, Ralph and Engel, Robert",
  title        = "{A} Framework for Network Protocol Software",
  journal      = sigplan # " (" # pot # "Tenth Annual Conference on Object-Oriented Programming Systems, Languages, and Applications, OOPSLA '95)",
  year         = 1995,
  volume       = 30,
  number       = 10,
  pages        = "358--369",
  month        = oct,
  keywords     = "mux, factories, architecture model, strategy pattern, visitor
    pattern, prototype pattern, atm signalling, evaluation",
  abstract     = "Writing software to control networks is important and
    difficult.  It must be efficient, reliable, and flexible.  Conduits+ is a
    framework for network software that has been used to implement the
    signalling system of a mullti-protocol ATM access switch.  An earlier
    version was used to implement TCP/IP.  It reduces the complexity of network
    software, makes it easier to extend or modify network protocols, and is
    sufficiently efficient.  Conduits+ shows the power of a componentized
    object-oriented framework and of common object-oriented design patterns.", 
  location     = "https://doi.org/10.1145/217839.217875"
}

@Article{sarosd,
  author       = "Ian~A. Mcleod",
  title        = "Storage and Retrieval of Structured Documents",
  journal      = "Journal of Information Processing and Management",
  year         = 1990,
  volume       = 26,
  number       = 2,
  pages        = "197--208",
  keywords     = "text retrieval, query language",
  abstract     = "There have been a number of important document related
    activities which suggest the need for a new model for text.  ISO standards
    for document description have been recently developed.  These standards
    view documents as hierarchical objects and it is likely that languages such
    as SGML will become widely used in the near future for document markup.  As
    structured documents become available, so there will be a need to evolve
    tools to take advantage of structural knowledge.  The goal of the work
    described here is to develop such tools.  A conceptual model for
    bibliographic data has been designed.  The model is known as Maestro
    (Management Environment for Structured Text Retrieval and Organization).
    It supports structured documents and provides a query language to retrieve
    and link information contained in these structures, in this paper, an
    overview of Maestro is presented together with an outline of the basic
    implementation strategy.", 
  location     = "https://doi.org/10.1016/0306-4573%2890%2990025-W"
}

@Article{pwthp,
  author       = "Andrew Davison",
  title        = "Programming With the {HTTP} Protocol",
  journal      = "Web Techniques",
  year         = 1996,
  volume       = 1,
  number       = 4,
  month        = jul,
  keywords     = "http, gets, web pages",
  location     = "http://www.cs.mu.oz.au/~ad"
}

@Article{sftffrl,
  author       = "Degermark, Mikael and Brodnik, Andrej and Carlsson, Svante and Pink, Stephen",
  title        = "Small Forwarding Tables for Fast Routing Lookups",
  journal      = ccr # " (" # pot # "ACM SIGCOMM Conference on Applications, Technologies, Architectures, and Protocols for Computer Communication, SIGCOMM '97)",
  year         = 1997,
  volume       = 27,
  number       = 4,
  pages        = "3--14",
  month        = oct,
  keywords     = "routing tables, forwarding, performance",
  abstract     = "For some time, the networking community has assumed that it
    is impossible to do IP routing lookups in software fast enough to support
    gigabit speeds.  IP routing lookups must find the routing entry with the
    longest matching prefix, a task that has been thought to require hardware
    support at lookup frequencies of millions per second.We present a
    forwarding table data structure designed for quick routing lookups.
    Forwarding tables are small enough to fit in the cache of a conventional
    general purpose processor.  With the table in cache, a 200 MHz Pentium Pro
    or a 333 MHz Alpha 21164 can perform a few million lookups per second.
    This means that it is feasible to do a full routing lookup for each IP
    packet at gigabit speeds without special hardware.The forwarding tables are
    very small, a large routing table with 40,000 routing entries can be
    compacted to a forwarding table of 150-160 Kbytes.  A lookup typically
    requires less than 100 instructions on an Alpha, using eight memory
    references accessing a total of 14 bytes.",
  location     = "https://doi.org/10.1145/263105.263133"
}

@Article{ddcfhpc,
  author       = "Matheou, George and Evripidou, Paraskevas",
  title        = "Data-Driven Concurrency for High Performance Computing",
  journal      = "ACM Transactions on Architecture and Code Optimization",
  year         = 2017,
  volume       = 14,
  number       = 4,
  pages        = 53,
  month        = dec,
  keywords     = "data-driven multithreading, distributed execution, runtime
    system, high-performance computing, communication management, multi-core
    scheduling",
  abstract     = "In this work, we utilize dynamic dataflow/data-driven
    techniques to improve the performance of high performance computing (HPC)
    systems.  The proposed techniques are implemented and evaluated through an
    efficient, portable, and robust programming framework that enables
    data-driven concurrency on HPC systems.  The proposed framework is based on
    data-driven multithreading (DDM), a hybrid control-flow/dataflow model that
    schedules threads based on data availability on sequential processors.  The
    proposed framework was evaluated using several benchmarks, with different
    characteristics, on two different systems: a 4-node AMD system with a total
    of 128 cores and a 64-node Intel HPC system with a total of 768 cores.  The
    performance evaluation shows that the proposed framework scales well and
    tolerates scheduling overheads and memory latencies effectively.  We also
    compare our framework to MPI, DDM-VM, and OmpSs&commat;Cluster.  The
    comparison results show that the proposed framework obtains comparable or
    better performance.", 
  location     = "https://doi.org/10.1145/3162014"
}

@Article{tfrppt,
  author       = "Anderson, David~P.",
  title        = "Techniques for Reducing Pen Plotting Time",
  journal      = tog,
  year         = 1983,
  volume       = 2,
  number       = 3,
  pages        = "197--212",
  month        = jul,
  keywords     = "line drawing, plotting, minimization, data structure, quadtree",
  abstract     = "The amount of time used by a pen plotter in drawing a set of
    line segments depends on the order and directions in which the segments are
    drawn, and can generally be reduced by reordering and redirecting the
    segments.  This paper represents practical techniques for reducing plotting
    time.  A method is proposed in which a buffer of segments in maintained,
    and the criterion used in choosing a segment from the buffer to draw is
    that of closeness to the current pen position.  By storing the segment
    endpoints in a quadtree data structure, it is possible to find the closest
    endpoint in an amount of time which is essentially independent of the
    buffer size.  We give algorithms for inserting, deleting, and finding
    closest points in the quadtree.  The performance of the plotting time
    reduction program in a sample of real-world applications is given.  Test
    cases from data plotting, computer-aided design and VLSI design are used.", 
  location     = "https://doi.org/10.1145/357323.357327"
}

@Article{dotboacdn,
  author       = "Muayyad Al-Chalabi and William~J. Liss",
  title        = "Design of the {B}ank of {A}merica {C}alifornia Data Network",
  journal      = "AT\&T Technical Journal",
  year         = 1988,
  pages        = "87--106",
  month        = nov # "/" # dec,
  keywords     = "system engineering, datakit, network management, performance",
  abstract     = "This paper describes Bank of America's California data
    network, a corporate utility network that uses AT&T's Datakit
    virtual-circuit-switch technology to consolidate multiple networks into a
    single network.  The network is managed by AT&T's StarKeeper
    network-management system and Dataphone II level-IV system controller.  The
    network architecture consists of an access network that connects branches
    to hubs, and a backbone network that interconnects hubs and data centers.
    We address three fundamental areas: optimization of the network topology
    and node configuration, performance analysis, and network management.
    Network optimization deals with determining the optimal number of nodes,
    access facilities engineering, and backbone configuration and routine.
    Performance analysis shows the end-to-end delays for the applications.  In
    the network management area, we discuss administration, disaster recovery,
    network monitoring , and data collection." 
}

@Article{teonn40,
  author       = "Matt Anderson",
  title        = "The Evolution of {NTFS}: {NTFS} 4.0",
  journal      = "Ars Technica",
  keywords     = "file systems",
  abstract     = "Welcome to Part I of my series, the Evolution of NTFS. Part I
    deals with NTFS u through NTFS 1.1, the version of NTFS found in Windows NT
    4.0 (and commonly called NTFS 4.0).  The article will give background t the
    development o NTFS, and foreshadow some o the important changes found in
    the next generation of NTF found in Windows 2000.  Part II wil focus
    completely on NTFS 5.0 (yep, even Microsoft skipped a few numbers), and Par
    III will talk about ways you ca integrate NTFS into a multi-OS environment.
    If you're wanting to learn more about the version of NTFS found in Windows
    2000, start here.  99% o this data is related to NTFS 5.0, and won't be
    repeated in Part II.", 
  location     = "http://archive.arstechnica.com/paedia/n/ntfs.html"
}

@Article{teonn50,
  author       = "Matt Anderson",
  title        = "The Evolution of {NTFS}: {NTFS} 5.0",
  journal      = "Ars Technica",
  keywords     = "file system",
  abstract     = "What's in Part II? Part II is all about NTFS as it stands in
    Windows 2000.  I'm going to cover most of the more highly touted features
    of the semi-new filesystem, including Encrypting Filesystem (EFS),
    Distributed Link Tracking, Quotas, and more.  NTFS 5.0, as it's called in
    Windows 2000, is an important new step in the world of Win32 OSes, and even
    folks who don't use NTWin2K should be interested.  How is it important?
    Well, from an overview perspective, most of the new techs that I covered in
    Windows 2000: 5-n-5 Top Features require the added functionality laid down
    by the new NTFS release.  No matter what you're using now, if you're a
    Microsoft OS user, you'll be getting acquainted with a form of NTFS in the
    near future.", 
  location     = "http://archive.arstechnica.com/paedia/n/ntfs/ntfs5-1.html"
}

@InProceedings{amitbpl,
  author       = "Kristensen, Bent Bruun and Madsen, Ole Lehrmann and M{\o}ller-Pedersen, Birger and Nygaard, Kristen",
   title        = "Abstraction Mechanisms in the {B}eta Programming Language",
  booktitle     = pot # "10th Annual " # popl,
  year         = 1983,
  editor       = "Alan Demers and Tim Teitelbaum",
  pages        = "285--298",
  address      = "Austin, Texas",
  month        = "24--26 " # jan,
  keywords     = "language design, object-oriented language, hierarchies,
    subclassing",
  abstract     = "The BETA programming language is developed as part of the
    BETA project.  The purpose of this project is to develop concepts,
    constructs and tools in the field of programming and programming
    languages. BETA has been developed from 1975 on.", 
  location     = "https://doi.org/10.1145/567067.567094"
}

@InProceedings{mdb,
  author       = "Bergel, Alexandre and Ducasse, Stephane and Putney, Colin and Wuyts, Roel",
  title        = "Meta-Driven Browsers",
  booktitle    = "Advances in Smalltalk",
  year         = 2006,
  editor       = "Wolfgang De~Meuter",
  pages        = "134--156",
  publisher    = "Springer",
  address      = "Prague, Czechoslovakia",
  series       = lncs,
  volume       = 4406,
  month        = "4--8 " # sep,
  keywords     = "tools, metamodeling, ui, Browsers, squeak, smalltalk, domain
    models",
  abstract     = "Smalltalk is not only an object-oriented programming
    language; it is also known for its extensive integrated development
    environment supporting interactive and dynamic programming.  While the
    default tools are adequate for browsing the code and developing
    applications, it is often cumbersome to extend the environment to support
    new language constructs or to build additional tools supporting new ways of
    navigating and presenting source code.  In this paper, we present the
    OmniBrowser, a browser framework that supports the definition of browsers
    based on an explicit metamodel.  With OmniBrowser a domain model is
    described in a graph and the navigation in this graph is specified in its
    associated metagraph.  We present how new browsers are built from
    predefined parts and how new tools are easily described.  The browser
    framework is implemented in the Squeak Smalltalk environment.  This paper
    shows several concrete instantiations of the framework: a remake of the
    ubiquitous Smalltalk System Browser, and a coverage browser.", 
  location     = "https://doi.org/10.1007/978-3-540-71836-9_7"
}

@InProceedings{acooet,
  author       = "Small, Christopher and Seltzer, Margo",
  title        = "{A} Comparison of {OS} Extension Technologies",
  booktitle    = pot # "1996 USENIX Annual Technical Conference",
  year         = 1996,
  pages        = "41--54",
  address      = sdca,
  month        = "22--26 " # jan,
  keywords     = "operating systems, device drivers, kernel modifications,
    user-space code, up-calls, kernel modules, os security",
  abstract     = "The current trend in operating systems research is to allow
    applications to dynamically extend the kernel to improve application
    performance or extend functionality, but the most effective approach to
    extensibility remains unclear.  Some systems use safe languages to permit
    code to be downloaded directly into the kernel; other systems provide
    in-kernel interpreters to execute extension code; still others use software
    techniques to ensure the safety of kernel extensions.  The key
    characteristics that distinguish these systems are the philosophy behind
    extensibility and the technology used to implement extensibility.  This
    paper presents a taxonomy of the types of extensions that might be
    desirable in an extensible operating system, evaluates the performance cost
    of various extension technologies currently being employed, and compares
    the cost of adding a kernel extension to the benefit of having the
    extension in the kernel.  Our results show that compiled technologies (e.g.
    Modula-3 and software fault isolation) are good candidates for implementing
    general-purpose kernel extensions, but that the overhead of interpreted
    languages is sufficiently high that they are inappropriate for this use.", 
  location     = "https://www.eecs.harvard.edu/margo/papers/usenix96-os/paper.ps"
}

@InProceedings{lddeim,
  author       = "Goel, Shantanu and Duchamp, Dan",
  title        = "Linux Device Driver Emulation in {M}ach",
  booktitle    = pot # "1996 USENIX Annual Technical Conference",
  year         = 1996,
  pages        = "65--74",
  address      = sdca,
  month        = "22--26 " # jan,
  keywords     = "device drivers, linux, mach, emulation",
  abstract     = "We describe the design and performance of code added to the
    Mach microkernel (Mach 4.0, version UK02p21) that permits one to build a
    Mach kernel that includes unmodified Linux device drivers.  We have written
    emulation code to support all Linux 1.3.35 network and SCSI drivers for the
    ISA and PCI I/O buses.  Emulation increases latency, but very little.  The
    degree depends on both device and operation, and varies from 2 microseconds
    for receiving small (60 byte) network packets up to 197 microseconds for
    writing 16KB to an ISA SCSI device.",
  location     = "https://www.usenix.org/publications/library/proceedings/sd96/full_papers/goel.ps"
}

@InProceedings{ssootoclou,
  author       = "Vaziri, Mandana and Jackson, Daniel",
  title        = "Some Shortcomings of {OCL}, the Object Constrain Language of {UML}",
  booktitle    = pot # "Technology of Object-Oriented Languages and Systems (TOOLS '00)",
  year         = 2000,
  pages        = "555--572",
  address      = "Santa Barbara, " # CA,
  month        = "30 July-3 August",
  keywords     = "ocl, alloy, uml metamodel",
  abstract     = "We illustrate some shortcomings of the Object Constraint
    Language of UML, and ways in which it may be improved, by comparing it to
    Alloy, a simile object modeling language.  We use the core package of the
    UML metamodel as a basis for the comparison.",
  location     = "http://dx.doi.org/10.1109/TOOLS.2000.10063"
}

@InProceedings{apbarwfaacs,
  author       = "P. Tonella and R. Fiutem and G. Antoniol and E. Merlo",
  title        = "Augmenting Pattern-Based Architectural Recovery with Flow Analysis:  a Case Study",
  booktitle    = pot # "3rd Working Conference on Reverse Engineering (WCRE '96)",
  year         = 1996,
  pages        = "198--208",
  month        = "8--10 " # nov,
  keywords     = "patterns, architectural analysis, architectural recognizers",
  abstract     = "Understanding the overall organization of a software system,
    i.e. its software architecture, is often required during software
    maintenance: tools can help maintainers in managing the evolution of legacy
    systems, by showing them architectural information.  In this paper, the
    analysis of a medium-sized application using a pattern based architectural
    recovery environment is presented.  The results obtained give useful
    information about the system architecture but also show some limitations of
    a purely pattern based approach.  To overcome such limitations,
    architectural analysis algorithms have been augmented with information
    about control and data flow and the case study application has been
    re-analyzed.  Complementing pattern matching with flow information has
    allowed to detect architectural constructs also when they are spread over
    different procedures in source code and to extract useful additional
    information through the use of constant propagation and slicing.", 
  location     = "0-8186-7674-4"
}

@InProceedings{ucailsr,
  author       = "T.~A. Wiggerts",
  title        = "Using Clustering Algorithms in Legacy Systems Remodularization",
  booktitle    = pot # "4th Working Conference on Reverse Engineering (WCRE '97)",
  year         = 1997,
  pages        = "33--43",
  month        = "8--10 " # nov,
  keywords     = "clustering, similarity, optimization, hierarchical
    algorithms, rmodularization",
  abstract     = "Incited by the observation that cluster analysis and the 
    remodularization of software systems solve similar problems, we have done
    research in both these areas in order to provide theoretical background for
    the application of cluster analysis in systems remodularization.  In this
    article we present an overview of cluster analysis and of systems
    remodularization.  It appears that system remodularization techniques often
    either reinvent clustering techniques or could be augmented by them.  We
    also give directions for further research.",
  location     = "0-8186-7674-4"
}

@InProceedings{anefsmnaac,
  author       = "Robert Lake and Laura Pate",
  title        = "{A} Network Environment for Studying Multimedia Network Architecture and Control",
  booktitle    = "IEEE Global Telecommunications Conference and Exhibition",
  year         = 1989,
  pages        = "1232--1236",
  address      = "Dallas, Texas",
  month        = "27--30 " # nov,
  keywords     = "multimedia applications, multimedia services, multimedia
    mail, multimedia databases",
  abstract     = "Bellcore's Integrated Media Architecture Laboratory (IMAL)
    studies architecture, control and network design issues of network-based
    multimedia services.  This paper will present an overview of a set of
    likely multimedia services that use audio, video, graphics, text, and other
    sorts of data; describe the laboratory environment we use to support these
    services; and provide a high-level description of how we have implemented
    these services as networked modules."
}

@InProceedings{wberafcwasacasotip,
  author       = "Lakshman, T.~V. and Suter, B. and Madhow, U.",
  title        = "Window-Based Error Recovery and Flow Control with a Slow Acknowledgement Channel: {A} Study of {TCP}/{IP} Performance",
  booktitle    = pot # "Sixteenth Annual Joint Conference of the IEEE Computer and Communications Societies (INFOCOM '97)",
  year         = 1997,
  pages        = "1199--1210",
  month        = "9--11 " # apr,
  keywords     = "path models, random loss, multiple collections, buffer sharing",
  abstract     = "With the envisaged growth in Internet access services over
    networks with asymmetric links such as Asymmetric Digital Subscriber Line
    (ADSL) and Hybrid Fiber Coax (HFC), it becomes crucial to evaluate the
    performance of window-based protocols over systems in which the reverse
    link is considerably slower than the forward link.  Even if the actual
    bandwidth asymmetry is moderate, high effective asymmetries can result
    because of bidirectional traffic.  Our objective is to determine, whether
    TCP/IP performs reasonably in a setting in which the reverse link is the
    primary bottleneck.Our main results are: (1) For both the prevalent Tahoe
    version with Fast Retransmit and the Reno version of TCP, we determine the
    throughput as a function of buffering, round-trip times and (normalized)
    asymmetry.  (2) Asymmetry increases TCP's already high sensitivity to
    random packet losses.  (3) Congestion in the reverse path adds considerably
    to TCP's unfairness when multiple connections share the reverse link.",
  location     = "0-8186-7780-5"
}

@InProceedings{tcpivc,
  author       = "Alain~J. Martin",
  title        = "Translating Concurrent Programs Into {VLSI} Chips",
  booktitle    = "Parallel Architectures and Languages Europe (PARLE '92)",
  year         = 1992,
  editor       = "Etiemble, D. and Syre, J.~C.",
  pages        = "515--532",
  volume       = 605,
  series       = lncs,
  publisher    = "Springer",
  address      = "Paris, France",
  month        = "15--18 " # jun,
  keywords     = "production rule, clock signal, clock period, program
    transformation, vlsi design ",
  abstract     = "This paper reviews the results of almost a decade of research
    in the synthesis of asynchronous VLSI circuits from concurrent programs.
    In view of these results, it is argued that a method based on program
    transformations can produce circuits that are both correct by construction
    and efficient.  The design of the first asynchronous microprocessor is used
    as an example.", 
  location     = "http://dx.doi.org/10.1007/3-540-55599-4_108"
}

@InProceedings{uedmtilsre,
  author       = "Jean-Marc Debaud",
  title        = "Using Executable Domain Models to Implement Legacy Software Re-engineering",
  booktitle    = pot # "OOPSLA'95 Workshop on Legacy Systems and Object Technology",
  year         = 1995,
  address      = atx,
  month        = "16 " # oct,
  keywords     = "domain modeling, reverse engineering",
  abstract     = "In this position paper, we advocate a domain-centric approach
    to the evolution of legacy systems.  The migration of legacy systems is a
    difficult endeavor because traditional methods have two principal
    deficiencies.  First, they fail to capture the context of a system, i.e.,
    its domain.  Second, the legacy system’s comprehension results are not
    directly usable for the system evolution.  We propose the construction of
    executable domain models to alleviate both problems.  The construction of
    an executable domain model entails a process of domain analysis that leads
    to a domain model, as well as the transition of the former to an executable
    state.  The domain model provides domain expectations that drive legacy
    system understanding.  The executable domain model provides a medium in
    which the result of the legacy system comprehension can be recorded.  In
    fact, the executable domain model is instantiated using the system
    requirements derived during program comprehension.  The artifact thus
    created takes the role of the re-engineered program.  Our work uses the
    technique of object-oriented frameworks (OOF) as the executable domain
    model representation.", 
  location     = "ftp://ftp.cc.gatech.edu/pub/groups/reverse/repository/legacy-RE.ps"
}

@InProceedings{cpatav,
  author       = "Michael Deck",
  title        = "Cleanroom Practice: {A} Theme and Variations",
  booktitle    = pot # "9th International Software Quality Week",
  year         = 1996,
  keywords     = "software development, testing, specifications"
}

@TechReport{dacsbssbsalbl,
  author       = "P.~Emerald Chung and Yennun Huang and Shalini Yajnik and
    Deron Liang and Joanne~C. Shih and Chung-Yih Wang and Yi-Min Wang",
  title        = "{DCOM} and {CORBA} Side by Side, Step by Step, and Layer by Layer",
  institution  = "Bell Laboratories, Lucent Technologies",
  address      = "Murray Hill, New Jersey",
  keywords     = "corba, dom, distributed computing, architectures",
  abstract     = "DCOM (Distributed Component Object Model) and CORBA (Common
    Object Request Broker Architecture) are two popular distributed object
    models.  In this paper, we make architectural comparison of DCOM and CORBA
    at three different layers: basic programming architecture, remoting
    architecture, and the wire protocol architecture.  A step-by-step
    description of remote object activation and method invocation is provided
    to demonstrate the similarities and differences of the two frameworks.  A
    primary goal is for people who are already familiar with one model to
    quickly understand the basic architecture of the other.",
  location     = "http://research.microsoft.com/~ymwangspapers/HTML/DCOMnCORBA/S.html"
}

@TechReport{crfrtcs,
  author       = "D. Ferrari",
  title        = "Client Requirements for Real-Time Communication Services",
  institution  = "Internet Engineering Task Force, Network Working Group",
  year         = 1990,
  type         = "Request for Comments",
  number       = 1193,
  address      = bca,
  month        = nov,
  keywords     = "client requests, performance, delay, reliability,
    translation",
  abstract     = "A real-time communication service provides its clients with
    the ability to specify their performance requirements and to obtain
    guarantees about the satisfaction of those requirements.  In this paper, we
    propose a set of performance specifications that seem appropriate for such
    services; they include various types of delay bounds, throughput bounds,
    and reliability bounds.  We also describe other requirements and desirable
    properties from a client's viewpoint, and the ways in which each
    requirement is to be translated to make it suitable for lower levels in the
    protocol hierarchy.  Finally, we present some examples of requirements
    specification, and discuss some of the possible objections to our
    approach.", 
  location     = "https://tools.ietf.org/html/rfc1193"
}

@TechReport{agaftalbp,
  author       = "Edward~J. Anderson and Michael~C. Ferris",
  title        = "{A} Genetic Algorithm for the Assembly Line Balancing Problem",
  institution  = "Optimization Group, UW-Madison Computer Sciences, " # uwisc,
  year         = 1990,
  number       = 926,
  address      = madw,
  keywords     = "genetic algorithms, parallel computing",
  abstract     = "",
  location     = "ftp://ftp.cs.wisc.edu/tech-reports/reports/1990/tr926"
}

@TechReport{msltfoesatlosr,
  author       = "Robert~M. Brady and Ross~J. Anderson and Robin~C. Ball",
  title        = "Murphy's Law, the Fitness of Evolving Species, and the Limits of Software Reliability",
  institution  = "Computing Laboratory, Cambridge University",
  year         = 1998,
  type         = "UCAM-CL-TR",
  number       = 471,
  address      = cen,
  month        = sep,
  keywords     = "software reliability, evolving species, reliability growth
    model, software development, poisson distribution, experimental
    measurement, mass market computing, biological evolution, spiral model,
    statistical thermodynamics, software errors, software assurance,
    evolutionary development model observed reliability growth, one-off
    software development",
  abstract     = "We tackle two problems of interest to the software assurance
    community. Firstly, existing models of software development (such as the
    waterfall and spiral models) are oriented towards one-off software
    development projects, while the growth of mass market computing has led to
    a world in which most software consists of packages which follow an
    evolutionary development model.  Thisleads us to ask whether anything
    interesting and useful may be said about evolutionary development.  We
    answer in the afﬁrmative.  Secondly, existing reliability growth models
    emphasise the Poisson distribution of individual software bugs, while the
    empirically observed reliability growth for large systems is asymptotically
    slower than this.  We provide a rigorous explanation of this phenomenon.
    Our reliability growth model is inspired by statistical thermodynamics, but
    also applies to biological evolution.  It is in close agreement with
    experimental measurements of the ﬁtness of an evolving species and the
    reliability of commercial software products.  However, it shows that there
    are signiﬁcant differences between the evolution of software and the
    evolution of species.  In particular, we establish maximisation properties
    corresponding to Murphy’s law which work to the advantage of a biological
    species, but to the detriment of software reliability.", 
  location     = "https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-471.pdf"
}

@TechReport{aniotil,
  author       = "Todd~A. Proebsting and Gregg~M. Townsend",
  title        = "{A} New Implementation of the {I}con Language",
  institution  = csd # uaz,
  year         = 1999,
  number       = "TR 99-13",
  address      = taz,
  abstract     = "We describe Jcon, a new, Java-based implementation of the
    Icon programming language.  The implementation includes a compiler and
    runtime system.  The runtime system is novel in its concise and efficient
    object-oriented implementation of a dynamically typed language, as well as
    its simple mechanism for realizing Icon generators.",
  month        = "4 " # oct,
  keywords     = "icon, java, object-oriented programming, generators, language
    implementation, backtracking, intermediate representations",
  location     = "https://www.microsoft.com/en-us/research/publication/a-new-implementation-of-the-icon-language/"
}

@TechReport{iaf7tcftutsststg,
  author       = "Aaron Sawdey and Matthew O'Keefe and Terrance Parr",
  title        = "Implementing a {F}ortran 77 to {CM} {F}ortran Translator Using the {SORCERER} Source-To-Source Translator Generator",
  institution  = "University of Minnesota",
  year         = 1993,
  type         = "AHPCRC Preprint",
  number       = "93-102",
  month        = oct,
  address      = "",
  keywords     = "language translation, tree transformations, intermediate
    representations, high-performance computing",
  abstract     = "",
  location     = ""
}

@TechReport{ltchamfsp,
  author       = "Lawrence Bernstein and David Klappholz",
  title        = "Live-Through Case Histories as Motivation for Software Process",
  institution  = "New Jersey Center for Software Engineering",
  keywords     = "capstone courses, requirements analysis, case histories,
    project management",
  location     = "http://www.njcse.org/Documents/version40.pdf"
}

@TechReport{sscsh,
  author       = "Cay~S. Horstmann",
  title        = "Safe {STL}",
  abstract     = "STL, the Standard Template Library designed by Alexander
    Stepanov and Meng Lee, is slated to become a part of the ANSI/ISO C++
    Standard.  Reaction to STL has been mixed.  Some programmers applaud its
    elegance and power, others find flaws with the interface, naming
    conventions, multithread support or safety.  While STL may not be the
    perfect container class library, it is here to stay.  I designed this small
    but useful enhancement to make STL safer to use.  Safe STL catches many
    typical STL programming errors at runtime (and a few at compile time).",
  keywords     = "stl, c++, programming errors, iterators",
  location     = "http://horstmann.com/safestl.html"
}

@TechReport{fasfathop,
  author       = "Craig~A. Damon and Ralph Melton and Robert~J. Allen and Elizabeth Bigelow and James~M. Ivers and David Garlan",
  title        = "Formalizing a Specification for Analysis:  The {HLA} Ownership Properties",
  institution  = scs # cmu,
  year         = 1999,
  number       = "CMU-CS-99-126",
  address      = ppa,
  month        = apr,
  keywords     = "Formal specification, model checking, Z specification language, distributed simulation",
  abstract     = "Interfaces are commonly specified using informal or
    semi-formal techniques, relying primarily on natural language descriptions.
    Such specifications, however, can easily overlook significant details and
    are not amenable to analysis by automated tools.  This paper looks at
    formalizing one portion of a substantial specification, the ownership
    management chapter of the DoD HLA framework, and at the subsequent analysis
    using the tool Ladybug.", 
  location     = "http://www.cs.cmu.edu/afs/cs/project/nitpick/www/ownership.html"
}

@TechReport{csejf,
  author       = "John Foreman",
  title        = "Cleanroom Software Engineering",
  institution  = sei,
  year         = 2005,
  type         = "Software Technology Roadmap",
  address      = ppa,
  keywords     = "maturity, complementary technologies",
  abstract     = "Cleanroom software engineering is a theory-based
    team-oriented process for development and certification of high-reliability
    software systems under statistical quality control.  A principal objective
    of the Cleanroom process is development of software that exhibits zero
    failures in use.  The Cleanroom name is borrowed from hardware Cleanrooms,
    with their emphasis on rigorous engineering discipline and focus on defect
    prevention rather than defect removal.  Cleanroom combines mathematically
    based methods of software specification, design, and correctness
    verification with statistical, usage-based testing to certify software
    fitness for use.  Cleanroom projects have reported substantial gains in
    quality and productivity.  This report defines the Cleanroom Software
    Engineering Reference Model, or CRM.  The CRM is expressed in terms of a
    set of 14 Cleanroom processes and 20 work products.  It is intended as a
    guide for Cleanroom project management and performance, process assessment
    and improvement, and technology transfer and adoption.", 
  location     = "http://www.sei.cmu.edu/library/abstracts/reports/96tr022.cfm"
}

@Manual{atajsm,
  title        = "{ANT} Tutorial",
  author       = "Ashley J.~S. Mills",
  organization = "The University of Birmingham",
  year         = 2002,
  keywords     = "build management, xml, java",
  location     = "http://supportweb.cs.bham.ac.uk/docs/tutorials/docsystem/build/tutorials/ant/ant.html"
}

@Unpublished{ivbf,
  author       = "Bob Frankston",
  title        = "Implementing {VisiCalc}",
  keywords     = "visicalc, software development, apple ][, ",
  year         = 2003,
  month        = apr,
  location     = "http://rmf.vc/ImplementingVisiCalcV1"
}

@Misc{ifsi,
  author       = "Linas Vepstas",
  title        = "Is Free Software Inevitable?",
  year         = 2001,
  month        = feb # "-" # jul,
  keywords     = "free trade, free software, altruistic behavior, corporations,
    indirect investment, monopoly",
  location     = "https://www.linas.org/theory/freetrade.html"
}

@Misc{casp,
  author       = "Christian Tismer",
  title        = "Continuations and Stackless Python",
  howpublished = "web",
  keywords     = "continuations, generators, python",
  location     = "http://www.stackless.com/spcpaper.htm"
}

@Misc{coip,
  author       = "Jason Tackaberry",
  title        = "{CORBA} Objects in {P}ython",
  howpublished = "web",
  year         = 2000,
  month        = apr,
  keywords     = "distributed objects, corba, gnome, orb, idl",
  location     = "https://projects-old.gnome.org/ORBit2/orbit-python.pdf"
}

@Misc{abdsgts11,
  author       = "Dave Winer",
  title        = "{A} Busy Developer's Guide to {SOAP} 1.1",
  howpublished = "WWW",
  year         = 2001,
  month        = "2 " # apr,
  keywords     = "soap, xml",
  location     = "scripting.com/davenet/2001/04/04/aBusyDevelopersGuideToSoap.html"
}

@Misc{hmre,
  author       = "James Marshall",
  title        = "{HTTP} Made Really Easy",
  howpublished = "WWW",
  year         = 1997,
  month        = aug,
  keywords     = "transactions, head, post, proxies, 1.1, clients, services",
  location     = "https://www.jmarshall.com/easy/http/"
}

@Misc{aamtkspsitsosr,
  title        = "Analysis as Model: {T}homas {K}uhn's Paradigm Shift in the Structure of Scientific Revolutions",
  howpublished = "WWW",
  keywords     = "kuhn, philosophy of science",
  location     = "http://webpages.shepherd.edu/maustin/kuhn/kuhnpaper.htm"
}

@Misc{mnhiw,
  title        = "Mojo Nation --- How It Works",
  howpublished = "WWW",
  keywords     = "peer-to-peer networks, reputation systems, payment systems",
  location     = "http://archive.li/YxpAA"
}

@Misc{siema,
  author       = "Mitch Altman",
  title        = "Soldering is Easy",
  howpublished = "WWW",
  keywords     = "soldering",
  location     = "https://mightyohm.com/files/soldercomic/FullSolderComic_EN.pdf"
}

@Misc{suassfur,
  author       = "Ladd Angelius",
  title        = "Set Up a Simple Syndication Feed Using {RSS}",
  howpublished = "WWW",
  keywords     = "rss, distribution, xml",
  location     = "http://www.devx.com/xml/Article/10790"
}

