.so bibtex.header
		  
@string{ir95  = " (ACM SIGPLAN Workshop on Intermediate Representations, IR '95)"}
		  
@Book{tdoetn,
  author       = "Tom Nichols",
  title        = "The Death of Expertise",
  publisher    = oup,
  year         = 2017,
  address      = nyny,
  keywords     = "expertise, knowledge, politics, technocracy, education,
    media, merit", 
  location     = "HM 851.N54"
}

@Book{tsrjb,
  author       = "John Brunner",
  title        = "The Shockwave Rider",
  publisher    = "Harper \& Row",
  year         = 1975,
  address      = nyny,
  keywords     = "future, networking, security, secrecy",
  location     = "PR 6052.R8"
}

@Book{srs,
  author       = "Robin Sloan",
  title        = "Sourdough",
  publisher    = "Farrar, Straus and Giroux",
  year         = 2017,
  address      = nyny,
  keywords     = "techology, food science, breadmaking",
  location     = "PS 3619.L6278 S67"
}

@Book{snttd,
  author       = "Ian Zack",
  title        = "Say No to the Devil",
  publisher    = ucp,
  year         = 2015,
  address      = chil,
  keywords     = "blues, gary davis, guitarists, street preachers, folk music",
  location     = "ML 419.D386 Z33"
}

@Book{dicnm,
  author       = "Nancy MacLean",
  title        = "Democracy in Chains",
  publisher    = "Viking",
  year         = 2017,
  address      = nyny,
  keywords     = "libertarianism, democracy, the kochs, james buchanan, public
    choice economics, governance",
  location     = "HN 49.R33 M23"
}

@Book{plpip,
  author       = "Steve Gregory",
  title        = "Parallel Logic Programming in {PARLOG}",
  publisher    = "Addison-Wesley",
  year         = 1987,
  address      = "Wokingham, England",
  keywords     = "parallel logic programming, parlog, and/or tree model, and
    tree model, compile-time analysis",
  location     = "QA 76.73.P194 G74"
}

@Book{tghsr,
  author       = "Salman Rushdie",
  title        = "The Golden House",
  publisher    = "Random House",
  year         = 2017,
  address      = nyny,
  keywords     = "2016 us election, crime, india, visual artists",
  location     = "PR 6068.U757 G65"
}

@Book{tjgrbp,
  author       = "Robert~B. Parker",
  title        = "The Judas Goat",
  publisher    = "Houghton Mifflin",
  year         = 1978,
  address      = boma,
  keywords     = "terra, london, olympics",
  location     = "PS 3566.A686"
}

@Book{qobemh,
  author       = "Elaine~M. Hayes",
  title        = "Queen of Bebop",
  publisher    = "Ecco",
  year         = 2017,
  address      = nyny,
  keywords     = "sarah vaughan, jazz",
  location     = "ML 420.V3 H39"
}

@Book{prbp1992,
  author       = "Robert~B. Parker",
  title        = "Pastime",
  publisher    = "Berkley Books",
  year         = 1992,
  price        = "$7.99",
  address      = nyny,
  keywords     = "parents and children",
  location     = "PS 3566.A686 P34"
}

@Book{lfcib,
  author       = "Ian Bassingthwaighte",
  title        = "Live from Cairo",
  publisher    = "Scribner",
  year         = 2017,
  address      = nyny,
  keywords     = "displacement, egypt, cairo, revolution",
  location     = "PS 3602.A8492 L59"
}

@Book{ctew,
  author       = "Rubin Fine",
  title        = "Chess the Easy Way",
  publisher    = "David McKay",
  year         = 1942,
  address      = nyny,
  keywords     = "chess",
  location     = "GV 1445 F55"
}

@Book{whhrc,
  author       = "Hillary Rodham Clinton",
  title        = "What Happened",
  publisher    = "Simon \& Schuster",
  year         = 2017,
  address      = nyny,
  keywords     = "2016 election, politics, media",
  location     = "9 781501 175565"
}

@Book{rbmp,
  author       = "Michael Poore",
  title        = "Reincarnation Blues",
  publisher    = "Del Rey",
  year         = 2017,
  address      = nyny,
  keywords     = "reincarnation, death, learning, doing good",
  location     = "PS 3616.O644 R45"
}

@Book{zbb,
  author       = "Bob Berman",
  title        = "Zapped",
  publisher    = "Little, Brown",
  year         = 2017,
  address      = nyny,
  keywords     = "the electromagnetic spectrum",
  location     = "QC 358.5.B47"
}

@Book{gvrk,
  author       = "Rachel Khong",
  title        = "Goodbye, Vitamin",
  publisher    = "Henry Holt",
  year         = 2017,
  address      = nyny,
  keywords     = "alzheimer's, aimlessness",
  location     = "PS 3611.H66 G66"
}

@Book{l30mt,
  author       = "Max Tegmark",
  title        = "Life 3.0",
  publisher    = "Knopf",
  year         = 2017,
  address      = nyny,
  keywords     = "intelligence, artificial intelligence, AGI, cosmology",
  location     = "Q 334.7.T44"
}

@Book{trrmi,
  author       = "Ryan McIlvain",
  title        = "The Radicals",
  publisher    = "Hogarth",
  year         = 2018,
  address      = nyny,
  keywords     = "protest, violent action",
  location     = "PS 3613.C535 R33"
}

@Book{aaatp,
  author       = "Tim Peake",
  title        = "Ask an Astronaut",
  publisher    = "Little, Brown",
  year         = 2017,
  address      = nyny,
  keywords     = "iss, space travel, space walks, ",
  location     = ""
}

@Book{fcje,
  author       = "Jeffrey Eugenides",
  title        = "Fresh Complaint",
  publisher    = "Farrar, Straus, and Giroux",
  year         = 2017,
  address      = nyny,
  keywords     = "escape, travel, parentage, debt, dreams, separation,
    progress, artichokes, theft, duplicity",
  location     = "PS 3555.U4 A6"
}

@Book{twatp,
  author       = "Charles~C. Mann",
  title        = "The Wizard and the Prophet",
  publisher    = "Alfred~A. Knopf",
  year         = 2018,
  address      = nyny,
  keywords     = "ecology, technology, vogt, borlaug, green revolution",
  location     = "GE 56.V64 M36"
}

@Book{capfd,
  author       = "Fyodor Dostoevsky",
  title        = "Crime and Punishment",
  publisher    = "Liveright",
  year         = 2018,
  translator   = "Michael~R. Katz",
  address      = nyny,
  keywords     = "crime, punishment",
  location     = "PG 3326.P7"
}

@Book{rbds,
  title        = "Reconstruction",
  publisher    = "The Library of America",
  year         = 2018,
  editor       = "Brooks~D. Simpson",
  address      = nyny,
  keywords     = "civil war, reconstruction, politics"
}

@Book{sosv,
  author       = "Anna Yen",
  title        = "Sophia of Silicon Valley",
  publisher    = "William Morrow",
  year         = 2018,
  address      = nyny,
  keywords     = "work-life balance, entrepreneurs"
}

@Book{sdd,
  author       = "Deborah Davis",
  title        = "Strapless",
  publisher    = "Tarcher/Penguin",
  year         = 2003,
  address      = nyny,
  keywords     = "virginie amilie avegno gautreau, john singer sargent, paris
    art scene",
  location     = "ND 237.S3 D38"
}

@Book{thtc,
  author       = "T.~C. Boyle",
  title        = "The Harder They Come",
  publisher    = "Ecco",
  year         = 2015,
  address      = nyny,
  price        = "$15.88",
  keywords     = "violence, sovereign citizens, madness",
  location     = ""
}

@Book{ttmjhy,
  author       = "James Harvey Young",
  title        = "The Toadstool Millionaires",
  publisher    = pup,
  year         = 1961,
  address      = prnj,
  keywords     = "patent medicines, folk medicine",
  location     = "RM 671.A1 Y6"
}

@InBook{aplftcaibottamm,
  author       = "Dirk Riehle and Heinz Z{\" u}llighoven",
  title        = "Pattern Languages of Programm Design",
  chapter      = "2, {A} Pattern Language for Tool Construction and Integration Based on the Tools and Materials Metaphor",
  publisher    = "Addison-Wesley",
  year         = 1995,
  editor       = "James~O. Coplien and Douglas~C. Schmidt",
  pages        = "9-42",
  address      = rma,
  keywords     = "tool structure, object-oriented design",
  abstract     = "Why do people prefer to use certain software systems and why
    do they have problems using others? What is the quality within certain
    software that makes people soon feel familiar using it and lets them work
    efficiently? We believe that the key to this quality is found in systems
    that allow people to work according to their qualification and needs while
    using their skills and competence.  We have put together many of the things
    which have proved useful in software engineering over the last decades and
    have integrated these methods and techniques into a unifying approach - the
    Tools and Materials Metaphor.  It has guided us and other developers during
    analysis and design and has helped to envision and finally build systems of
    quality.",
  location     = "http://dirkriehle.com/computer-science/research/1994/plop-1994-tools.pdf"
}

@Article{dcmlamfic,
  author       = "Herath, Jayantha and Yamaguchi, Yoshinori and Saito, Nobuo and Yuba, Toshitsugu",
  title        = "Dataflow Computing Models, Languages, and Machines for Intelligence Computations",
  journal      = tse,
  year         = 1988,
  volume       = 14,
  number       = 12,
  pages        = "1805--1828",
  month        = dec,
  keywords     = "architecture, dataflow, functional and logic programming,
    parallel computation, performance analysis, recursion, control flow,
    symbolic computing",
  abstract     = "The authors compare dataflow computing models, languages, and
    dataflow computing machines for numerical and nonnumerical computations.
    The high-level-language-graph transformations that must be performed to
    achieve high performance for numerical and nonnumerical programs executed
    in a dataflow computing environment are described for Lisp, using the DCBL
    transformations.  Some general problems of dataflow computing machines are
    discussed.  Performance evaluation measurements obtained by executing
    benchmark programs in the ETL nonnumerical dataflow computing environment,
    the EM-3, are presented.",
  location     = "https://doi.org/10.1109/32.9065"
}

@Article{lfegaeodtfsra,
  author       = "Selby, Richard~W. and Porter, Adam~A.",
  title        = "Learning from Examples:  Generation and Evaluation of Decision Trees for Software Resource Analysis",
  journal      = tse,
  year         = 1988,
  volume       = 14,
  number       = 12,
  pages        = "1743--1757",
  month        = dec,
  keywords     = "analysis of variance, decision trees, measurement and
    empirical evaluation, learning from examples, machine learning, software
    effort and error analysis, software metrics",
  abstract     = "A general solution method for the automatic generation of 
    decision (or classification) trees is investigated.  The approach is to
    provide insights through in-depth empirical characterization and evaluation
    of decision trees for one problem domain, specifically, that of software
    resource data analysis.  The purpose of the decision trees is to identify
    classes of objects (software modules) that had high development effort,
    i.e.  in the uppermost quartile relative to past data.  Sixteen software
    systems ranging from 3000 to 112000 source lines have been selected for
    analysis from a NASA production environment.  The collection and analysis
    of 74 attributes (or metrics), for over 4700 objects, capture a multitude
    of information about the objects: development effort, faults, changes,
    design style, and implementation style.  A total of 9600 decision trees are
    automatically generated and evaluated.  The analysis focuses on the
    characterization and evaluation of decision tree accuracy, complexity, and
    composition.  The decision trees correctly identified 79.3% of the software
    modules that had high development effort or faults, on the average across
    all 9600 trees.  The decision trees generated from the best parameter
    combinations correctly identified 88.4% of the modules on the average.
    Visualization of the results is emphasized, and sample decision trees are
    included.", 
  location     = "https://doi.org/10.1109/32.9061"
}

@Article{paia,
  author       = "Keith~L. Clark",
  title        = "{PARLOG} and Its Applications",
  journal      = tse,
  year         = 1988,
  volume       = 14,
  number       = 12,
  pages        = "1792--1804",
  month        = dec,
  keywords     = "communicating processes, logic programming applications,
    logic programming languages, object-oriented programming,
    parallel-programming languages, difference lists",
  abstract     = "The key concepts of the parallel logic programming language 
    PARLOG are introduced by comparing the language with Prolog.  Some
    familiarity with Prolog and with the concepts of logic programming is
    assumed.  Two major application areas of PARLOG, systems programming and
    object-oriented programming, are illustrated.  Other applications are
    briefly surveyed.", 
  location     = "https://doi.org/10.1109/32.9064"
}

@Article{fafcmdtg,
  author       = "Dujardin, Eric and Amiel, Eric and Simon, Eric",
  title        = "Fast Algorithms for Compressed Multimethod Dispatch Table Generation",
  journal      = toplas,
  year         = 1998,
  volume       = 20,
  number       = 1,
  pages        = "116--165",
  month        = jan,
  keywords     = "algorithms, language, measurement, performance, dispatch
    tables, late binding, multimethods, optimization, pole types, run-time
    dispatch", 
  abstract     = "The efficiency of dynamic dispatch is a major impediment to
    the adoption of multimethods in object-oriented languages.  In this
    article, we propose a simple multimethod dispatch scheme based on
    compressed dispatch tables.  This scheme is applicable to any
    object-oriented language using a method precedence order that satisfies a
    specific monotonous property (e.g., as Cecil and Dylan) and guarantees that
    dynamic dispatch is performed in constant time, the latter being a major
    requirement for some languages and applications.  We provide efficient
    algorithms to build the dispatch tables, provide their worst-case
    complexity, and demonstrate the effectiveness of our scheme by real
    measurements performed on two large object-oriented applications.  Finally,
    we provide a detailed comparison of our technique with other existing
    techniques.",
  location     = "https://doi.org/10.1145/271510.271521"
}

@Article{icodt,
  author       = "Sreedhar, Vugranam~C. and Gao, Guang~R. and Lee, Yong-Fong",
  title        = "Incremental Computation of Dominator Trees",
  journal      = sigplan # ir95,
  year         = 1993,
  volume       = 30,
  number       = 3,
  pages        = "1--12",
  month        = mar,
  keywords     = "dominator trees, dj-graph, incremental maintenance,
    control-flow graphs",
  abstract     = "Data flow analysis based on an incremental approach may
    require that  the dominator tree be correctly maintained at all times.
    Previous solutions to the problem of incrementally maintaining dominator
    trees were restricted to reducible flowgraphs.  In this paper we present a
    new algorithm for incrementally maintaining the dominator tree of an
    arbitrary flowgraph, either reducible or irreducible, based on a program
    representation called the DJ-graph.  For the case where an edge is
    inserted, our algorithm is also faster than previous approaches (in the
    worst case).  For the deletion case, our algorithm is likely to run fast on
    the average cases.",
  location     = "https://doi.org/10.1145/202530.202531"
}

@Article{atsfjbs,
  author       = "Stata, Raymie and Abadi, Martin",
  title        = "A Type System for {J}ava Bytecode Subroutines",
  journal      = toplas,
  year         = 1999,
  volume       = 21,
  number       = 1,
  pages        = "90--137",
  month        = jan,
  keywords     = "bytecode verification, java, typing rules",
  abstract     = "Java is typically compiled into an intermediate language,
    JVML, that is interpreted by the Java Virtual Machine.  Because mobile JVML
    code is not always trusted, a bytecode verifier enforces static constraints
    that prevent various dynamic errors.  Given the importance of the bytecode
    verifier for security, its current descriptions are inadequate.  This
    article proposes using typing rules to describe the bytecode verifier
    because they are more precise than prose, clearer than code, and easier to
    reason about than either.  JVML has a subroutine construct which is used
    for the compilation of Java's try-finally statement.  Subroutines are a
    major source of complexity for the bytecode verifier because they are not
    obviously last-in/first-out and because they require a kind of
    polymorphism.  Focusing on subroutines, we isolate an interesting, small
    subset of JVML.  We give typing rules for this subset and prove their
    correctness.  Our type system constitutes a sound basis for bytecode
    verification and a rational reconstruction of a delicate part of Sun's
    bytecode verifier.",
  location     = "https://doi.org/10.1145/314602.314606"
}

@Article{a0ailtsdp,
  author       = "Apt, Krzysztof~R. and Brunekreef, Jacob and Partington, Vincent and Schaerf, Andrea",
  title        = "Alma-0: An Imperative Language that Supports Declarative Programming",
  journal      = toplas,
  year         = 1998,
  volume       = 20,
  number       = 5,
  pages        = "1014--1066",
  month        = sep,
  keywords     = "declarative programming, imperative programming, search
    modula 2, backtracking, reversible assignment, language extensions,
    multi-paradigm programming, logic programming",
  abstract     = "We describe a small programming language, called Alma-0, that
    augments the expressive power of imperative programming with a small number
    of features inspired by the logic programming paradigm.  These additions
    encourage declarative programming and make it a more attractive solutions
    for problems involving search.  We illustrate the use of Alma-0 by
    presenting solutions to a number of classical problems, including search,
    STRIPS planning, knapsack, and Eight Queens.  These solutions are
    substantially simpler than their counterparts written in the imperative or
    in the logic programming style and can be used for different purposes
    without any modification.  We also discuss the implementation of Alma-0 and
    an operational, executable, semantics of a large subset of the language.",
  location     = "https://doi.org/10.1145/293677.293679"
}

@Article{tdmiaacs,
  author       = "Stytz, M.~R. and Frieder, G. and Frieder, O.",
  title        = "Three-Dimensional Medical Imaging: Algorithms and Computer Systems",
  journal      = surveys,
  year         = 1991,
  volume       = 23,
  number       = 4,
  pages        = "421--499",
  month        = dec,
  keywords     = "computer graphics, medical imaging, surface rendering,
    three-dimensional imaging, volume rendering, algorithms, surface
    extraction",
  abstract     = "This paper presents an introduction to the field of
    three-dimensional medical imaging.  It presents medical imaging terms and
    concepts, summarizes the basic operations performed in three-dimensional
    medical imaging, and describes sample algorithms for accomplishing these
    operations.  The paper contains a synopsis of the architectures and
    algorithms used in eight machines to render three-dimensional medical
    images, with particular emphasis paid to their distinctive contributions.
    It compares the performance of the machines along several dimensions,
    including image resolution, elapsed time to form an image, imaging
    algorithms used in the machine, and the degree of parallelism used in the
    architecture.  The paper concludes with general trends for future
    developments in this field and references on three-dimensional medical
    imaging.",
  location     = "https://doi.org/10.1145/125137.125155"
}

@Article{ehipi,
  author       = "M.~Donald MacLaren",
  title        = "Exception Handling in {PL}/{I}",
  journal      = sigplan # " (" # pot # "ACM Conference on Language Design for Reliable Software)",
  year         = 1977,
  volume       = 12,
  number       = 3,
  pages        = "101--104",
  month        = mar,
  keywords     = "pl/1, exceptional conditions, errors, interrupts, non-local
    go-tos, structured programming, code generation",
  abstract     = "The PL/I language's facilities for handling exceptional
    conditions are analyzed.  The description is based on the new PL/I
    standard.  Special attention is given to fine points which are not well
    known.  The analysis is generally critical.  It emphasizes problems in
    regards to implementation and structured programming.  A few suggestions
    for future language design are offered.",
  location     = "https://doi.org/10.1145/390017.808316"
}

@Article{wwwtiu,
  author       = "Tim Berners-Lee and Robert Cailliau and Jean-Fran{\c c}ois Groff and Bernd Pollermann",
  title        = "{W}orld-{W}ide {W}eb: The Information Universe",
  journal      = "Electronic Networking: Research, Applications and Policy",
  year         = 1992,
  volume       = 1,
  number       = 2,
  pages        = "74--82",
  month        = "Spring",
  keywords     = "information access, hypertext, document management",
  abstract     = {The World-Wide Web (W3) initiative is a practical project to
    bring a global information universe into existence using available
    technology.  This article describes the aims, data model, and protocols
    needed to implement the "web," and compares them with various contemporary
    systems.},
  location     = "www.w3.org/History/1992/ENRAP/Article_9202.txt"
}

@Article{apaffafhol,
  author       = "Ashley, J.~Michael and Dybvig, R.~Kent",
  title        = "{A} Practical and Flexible Flow Analysis for Higher-Order Languages",
  journal      = toplas,
  year         = 1998,
  volume       = 20,
  number       = 4,
  pages        = "845--868",
  month        = jul,
  keywords     = "abstract interpretation, higher-order languages, compiler
      optimizations, closures, scheme, flow analysis, data analysis",
  abstract     = "A flow analysis collects data-flow and control-flow
      information about programs.  A compiler can use this information to
      enable optimizations.  The analysis described in this article unifies and
      extends previous work on flow analysis for higher-order languages
      supporting assignment and control operators.  The analysis is abstract
      interpretation based and is parameterized over two polyvariance operators
      and a projection operator.  These operators are used to regulate the
      speed and accuracy of the analysis.  An implementation of the analysis is
      incorporated into and used in a production Scheme compiler.  The analysis
      can process any legal Scheme program without modification.  Others have
      demonstrated that a 0CFA analysis can enables the optimizations, but a
      0CFA analysis is O(n)3).  An O(n) instantiation of our analysis
      successfully enables the optimization of closure representations and
      procedure calls.  Experiments with the cheaper instantiation show that it
      is as effective as 0CFA for these optimizations.",
  location     = "https://doi.org/10.1145/291891.291898"
}

@Article{dokbswakba,
  author       = "Schoen, Eric and Smith, Reid~G. and Buchanan, Bruce~G.",
  title        = "Design of Knowledge-Based Systems with a Knowledge-Based Assistant",
  journal      = tse,
  year         = 1988,
  volume       = 14,
  number       = 12,
  pages        = "1771--1791",
  month        = dec,
  keywords     = "knowledge acquisition, knowledge-based systems,
    object-oriented programming, structured editing, programming environments,
    user interfaces",
  abstract     = "The authors propose a model for an intelligent assistant to
    aid in building knowledge-based systems (KBSs) and discuss a preliminary
    implementation.  The assistant participates in KBS construction, including
    acquisition of an initial model of a problem domain, acquisition of control
    and task-specific inference knowledge, testing and validation, and
    long-term maintenance of encoded knowledge.  The authors present a
    hypothetical scenario in which the assistant and a KBS designer cooperate
    to create an initial domain model and then discuss five categories of
    knowledge the assistant requires to offer such help.  They discuss two
    software technologies on which the assistant is based: an object-oriented
    programming language, and a user-interface framework.",
  location     = "https://doi.org/10.1109/32.9063"
}

@Article{hslanatpas,
  author       = "Abeysundara, Bandula~W. and Kamal, Ahmed~E.",
  title        = "High-Speed Local Area Networks and Their Performance:  {A} Survey",
  journal      = surveys,
  year         = 1991,
  volume       = 23,
  number       = 2,
  pages        = "221--264",
  month        = jun,
  keywords     = "access schemes, computer networks, data communication, medium
    access protocols, optical fiber networks, simulation, bus networks, ring
    networks, tree networks",
  abstract     = "At high data transmission rates, the packet transmission time
    of a local  area network (LAN) could become comparable to or less than the
    medium propagation delay.  The performance of many LAN schemes degrades
    rapidly when the packet transmission time becomes small comparative to the
    medium propagation delay.  This paper introduces LANs and discusses the
    performance degradation of LANs at high speeds.  It surveys recently
    proposed LAN schemes designed to operate at high data rates, including
    their performance characteristics desirable in LAN medium access protocols
    are identified and discussed.  The paper serves as a tutorial for readers
    less familiar with local computer communication networks.  It also serves
    as a survey of the state-of-the-art LANs.",
  location     = "https://doi.org/10.1145/103724.103726"
}

@Article{srtropeh,
  author       = "Melliar-Smith, P.~M. and Randell, B.",
  title        = "Software Reliability: The Role of Programmed Exception Handling",
  journal      = sigplan # " (" # pot # "ACM Conference on Language Design for Reliable Software)",
  year         = 1977,
  volume       = 12,
  number       = 3,
  pages        = "95--100",
  month        = mar,
  keywords     = "failures, errors, faults, exceptions, recovery blocks,
    failure handling, reliable software design",
  abstract     = "The paper discusses the basic concepts underlying the issue
    of software reliability, and argues that programmed exception handling is
    inappropriate for dealing with suspected software errors.  Instead it is
    shown, using an example program, how exception handling can be combined
    with the recovery block structure.  The result is to improve the
    effectiveness with which problems due to anticipated faulty input data,
    hardware components, etc., are dealt with, while continuing to provide
    means for recovering from unanticipated faults, including ones due to
    residual software design errors.", 
  location     = "https://doi.org/10.1145/390018.808315"
}

@Article{acotwapi,
  author       = "Diomidis Spinellis",
  title        = "{A} Critique of the {W}indows Application Programming Interface",
  journal      = "Computer Standards \& Interfaces",
  year         = 1993,
  volume       = 20,
  number       = 1,
  pages        = "1--8",
  month        = nov,
  keywords     = "function names, naming conventions, portability, type
    systems, name-space pollution",
  abstract     = "The architecture, interface, and functionality of the Windows
    Application Programming Interface (API) make it difficult to master and use
    effectively, and contribute negatively to the safety, robustness, and
    portability of the applications developed under it.  The API is structured
    around a large and constantly evolving set of functions and is based on a
    problematic shared library implementation.  The provided interfaces are
    complicated, nonorthogonal, abuse the type system, cause name-space
    pollution, and use inconsistent naming conventions.  In addition, the
    functionality of the interface suffers from inconsistency, incompleteness,
    and inadequate documentation.  Application developers, programming tool
    vendors, and Microsoft should face the above problems and provide
    appropriate solutions.", 
  location     = "https://doi.org/10.1016/S0920-5489%2898%2900012-9"
}

@Article{aaefeis,
  author       = "Erman, Lee~D. and Lark, Jay~S. and Hayes-Roth, Frederick",
  title        = "{ABE}:  An Environment for Engineering Intelligent Systems",
  journal      = tse,
  year         = 1993,
  volume       = 14,
  number       = 12,
  pages        = "1758--1770",
  month        = dec,
  keywords     = "cooperative operating system, distributed computing,
    intelligent-systems engineering, module-oriented programming, layered
    architecture, abstract machines",
  abstract     = "The ABE multilevel architecture for developing intelligent
    systems addresses the key problems of intelligent systems engineering:
    large-scale applications and the reuse and integration of software
    components.  ABE defines a virtual machine for module-oriented programming
    and a cooperative operating system that provides access to the capabilities
    of that virtual machine.  On top of the virtual machine, ABE provides a
    number of systemdesign and development frameworks, which embody such
    programming metaphors as control flow, blackboards, and dataflow.  These
    frameworks support the construction of capabilities, including knowledge
    processing tools, which span a range from primitive modules to skeletal
    systems.  Finally, applications can be built on skeletal systems.  In
    addition, ABE supports the importation of existing software, including both
    conventional and knowledge processing tools.",
  location     = "https://doi.org/10.1109/32.9062"
}

@Article{calwdt,
  author       = "Augustsson, Lennart",
  title        = "Cayenne --- {A} Language with Dependent Types",
  journal      = sigplan,
  year         = 1999,
  volume       = 34,
  number       = 1,
  pages        = "239--250",
  month        = jan,
  keywords     = "type systems, language design, dependent types, module systems",
  abstract     = "Cayenne is a Haskell-like language.  The main difference
    between Haskell and Cayenne is that Cayenne has dependent types, i.e., the
    result type of a function may depend on the argument value, and types of
    record components (which can be types or values) may depend on other
    components.  Cayenne also combines the syntactic categories for value
    expressions and type expressions; thus reducing the number of language
    concepts.Having dependent types and combined type and value expressions
    makes the language very powerful.  It is powerful enough that a special
    module concept is unnecessary; ordinary records suffice.  It is also
    powerful enough to encode predicate logic at the type level, allowing types
    to be used as specifications of programs.  However, this power comes at a
    cost: type checking of Cayenne is undecidable.  While this may appear to be
    a steep price to pay, it seems to work well in practice.", 
  location     = "https://doi.org/10.1145/291251.289451"
}

@Article{iomad,
  author       = "Litwin, Witold and Mark, Leo and Roussopoulos, Nick",
  title        = "Interoperability of Multiple Autonomous Databases",
  journal      = surveys,
  year         = 1990,
  volume       = 22,
  number       = 3,
  pages        = "267--293",
  month        = sep,
  keywords     = "database autonomy, database interoperability without global
    schema, distributed databases, federated databases, multidatabases,
    multidatabase language",
  abstract     = "Database systems were a solution to the problem of shared
    access to heterogeneous files created by multiple autonomous applications
    in a centralized environment.  To make data usage easier, the files were
    replaced by a globally integrated database.  To a large extent, the idea
    was successful, and many databases are now accessible through local and
    long-haul networks.  Unavoidably, users now need shared access to multiple
    autonomous databases.  The question is what the corresponding methodology
    should be.  Should one reapply the database approach to create globally
    integrated distributed database systems or should a new approach be
    introduced? We argue for a new approach to solving such data management
    system problems, called multidatabase or federated systems.  These systems
    make databases interoperable, that is, usable without a globally integrated
    schema.  They preserve the autonomy of each database yet support shared
    access.  Systems of this type will be of major importance in the future.
    This paper first discusses why this is the case.  Then, it presents
    methodologies for their design.  It further shows that major commerical
    relational database systems are evolving toward multidatabase systems.  The
    paper discusses their capabilities and limitations, presents and discusses
    a set of prototypes, and, finally, presents some current research issues.", 
  location     = "https://doi.org/10.1145/96602.96608"
}

@Article{bsansa,
  author       = "Joshua~J. Arulanandham and Cristian~S. Calude and Michael~J. Dinneen",
  title        = "Beadâ€“Sort: {A} Natural Sorting Algorithm",
  journal      = "The Bulletin of the European Association for Theoretical Computer Science",
  year         = 2002,
  volume       = 76,
  pages        = "153--162",
  keywords     = "sorting, linear sorts, sorting implementations",
  abstract     = "Nature is not only a source of minerals and precious stones
    but is also a mine of algorithms.  By observing and studying natural
    phenomena, computer algorithms can be extracted.  In this note, a simple
    natural phenomenon is used to design a sorting algorithm for positive
    integers, called here Bead-Sort.  The algorithm's run-time complexity
    ranges from O(1) to O(S) (S is the sum of the input integers) depending on
    the user's perspective.  Finally, three possible implementations are
    suggested.",
  location     = "https://www.cs.auckland.ac.nz/~mjd/misc/BeadSort5.pdf"
}

@Article{cois,
  author       = "Anish Arora and Paul Attie and Michael Evangelist and Mohamed Gouda",
  title        = "Convergence of Iteration Systems",
  journal      = "Distributed Computing",
  year         = 1993,
  volume       = 7,
  number       = 1,
  pages        = "43--53",
  month        = nov,
  keywords     = "convergence, stabilization, iteration systems, dependency graph",
  abstract     = "An iteration system is a set of assignment statements whose
    computation proceeds in steps: at each step, an arbitrary subset of the
    statements is executed in parallel.  The set of statements thus executed
    may differ at each step; however, it is required that each statement is
    executed infinitely often along the computation.  The convergence of such
    systems (to a fixed point) is typically verified by showing that the value
    of a given variant function is decreased by each step that causes a state
    change.  Such a proof requires an exponential number of cases (in the
    number of assignment statements) to be considered.  In this paper, we
    present alternative methods for verifying the convergence of iteration
    systems.  In most of these methods, upto a linear number of cases need to
    be considered.",
  location     = "https://doi.org/10.1007/BF02278855"
}

@Article{ttipl,
  author       = "Herriot, Robert~G.",
  title        = "Towards the Ideal Programming Language",
  journal      = sigplan # " (" # pot # "ACM Conference on Language Design for Reliable Software)",
  year         = 1977,
  volume       = 12,
  number       = 3,
  pages        = "56--62",
  month        = mar,
  keywords     = "types, simula class, instances, pascal, adjectives,
    modifiers, procedures, extensible languages, plasma, smalltalk, prepositions,
    imperative operators, applicative operators, which operator, passive operator",
  abstract     = "A programming language with good features and notation can
    help the programmer represent his abstractions in the programming language,
    and can also help someone else understand the original abstraction.  There
    have been numerous proposals for better features.  In this paper we propose
    several new ideas to improve the notation.  First we suggest that class
    instances be named with a sequence of identifiers consisting of the class
    name preceded by modifiers.  Then we propose that prepositions be placed
    before procedure parameters to suggest their role.  Finally, we suggest
    that applicative and imperative operations can be separated semantically,
    and then recombined syntactically through the use of the which and passive
    operators.",
  location     = "https://doi.org/10.1145/390017.808311"
}

@Article{assofli,
  author       = "Douence, R{\' e}mi and Fradet, Pascal",
  title        = "{A} Systematic Study of Functional Language Implementations",
  journal      = toplas,
  year         = 1998,
  volume       = 20,
  number       = 2,
  pages        = "344--387",
  month        = mar,
  keywords     = "abstract machines, compilers, combinators, functional
    programming, program transformation, comparative implementations",
  abstract     = "We introduce a unified framework to describe, relate,
    compare, and classify functional language implementations.  The compilation
    process is expressed as a succession of program transformations in the
    common framework.  At each step, different transformations model
    fundamental choices.  A benefit of this approach is to structure and
    decompose the implementation process.  The correctness proofs can be
    tackled independently for each step and amount to proving program
    transformations in the functional world.  This approach also paves the way
    to formal comparisons by making it possible to estimate the complexity of
    individual transformations or compositions of them.  Our study aims at
    covering the whole known design space of sequential functional language
    implementations.  In particular, we consider call-by-value, call-by-name,
    call-by-need reduction strategies as well as environment- and graph-based
    implementations.  We describe for each compilation step the diverse
    alternatives as program transformations.  In some cases, we illustrate how
    to compare or relate compilation techniques, express global optimizations,
    or hybrid implementations.  We also provide a classification of well-known
    abstract machines.", 
  location     = "https://doi.org/10.1145/276393.276397"
}

@Article{dobps,
  author       = "Chin, Roger~S. and Chanson, Samuel~T.",
  title        = "Distributed Object-Based Programming Systems",
  journal      = surveys,
  year         = 1991,
  volume       = 23,
  number       = 1,
  pages        = "91--124",
  month        = mar,
  keywords     = "capabilities, distributed operating systems, error recovery,
    method invocation, nested transactions, object-based programming languages,
    object model, object reliability, processor allocation, resource management,
    synchronization, transactions",
  abstract     = "The development of distributed operating systems and
    object-based programming languages makes possible an environment in which
    programs consisting of a set of interacting modules, or objects, may
    execute concurrently on a collection of loosely coupled processors.  An
    object-based programming language encourages a methodology for designing
    and creating a program as a set of autonomous components, whereas a
    distributed operating system permits a collection of workstations or
    personal computers to be treated as a single entity.  The amalgamation of
    these two concepts has resulted in systems that shall be referred to as
    distributed, object-based programming systems.  This paper discusses issues
    in the design and implementation of such systems.  Following the
    presentation of fundamental concepts and various object models, issues in
    object management, object interaction management, and physical resource
    management are discussed.  Extensive examples are drawn from existing
    systems.", 
  location     = "https://doi.org/10.1145/103162.103165"
}

@Article{setas,
  author       = "Guttag, Jhon~V. and Horowitz, Ellis and Musser, David~R.",
  title        = "Some Extensions to Algebraic Specifications",
  journal      = sigplan # " (" # pot # "ACM Conference on Language Design for Reliable Software)",
  year         = 1977,
  volume       = 12,
  number       = 3,
  pages        = "62--67",
  month        = mar,
  keywords     = "abstract data type, data structures, programming languages,
    procedure specification, error specification, correctness, functional
    programming",
  abstract     = "Algebraic specifications of abstract data types are beginning
    to gain wide currency.  In this paper we discuss an extension to this
    specification technique which allows the specification of procedures which
    alter their parameters, and various ways of handling the specification of
    error conditions.",
  location     = "https://doi.org/10.1145/800022.808312"
}

@Article{rdtsaeoipov,
  author       = "Buckle, Normand",
  title        = "Restricted Data Types, Specification and Enforcement of Invariant Properties of Variables",
  journal      = sigplan # " (" # pot # "ACM Conference on Language Design for Reliable Software)",
  year         = 1977,
  volume       = 12,
  number       = 3,
  pages        = "68--76",
  month        = mar,
  keywords     = "data type, invariant property, programming language,
    readability, reliability, restricted type, runtime verification, type checking",
  abstract     = "When defining a data type, it is often useful to specify
    restrictions on the permitted values of that type.  Pascal's subrange type
    declaration, a special case of this kind of constraint definition, has
    already proved itself to be quite useful.  Restricted data types allow more
    complex constraints to be defined and checked; for example, a variable
    could be declared of type odd integer or the day field of a
    date type variable could be checked for consistency with the
    year and month fields.  A simple mechanism is proposed, allowing the
    formulation of such constraints and their association with data types; the
    behaviour of a restricted type variable is described.  The effects of the
    use of such a mechanism on program reliability, readability and efficiency
    are discussed.", 
  location     = "https://doi.org/10.1145/800022.808313"
}

@Article{olsicm,
  author       = "Anger, Frank~D.",
  title        = "On {L}amport's Interprocessor Communication Model",
  journal      = toplas,
  year         = 1989,
  volume       = 11,
  number       = 3,
  pages        = "404--417",
  month        = jul,
  keywords     = "nonatomic operations, abstractions, axiom schemes",
  abstract     = "Leslie Lamport presented a set of axioms in 1979 that capture
    the essential properties of the temporal relationships between complex and
    perhaps unspecified activities within any system, and proceeded to use this
    axiom system to prove the correctness of sophisticated algorithms for
    reliable communication and mutual exclusion in systems without shared
    memory.  As a step toward a more complete metatheory of Lamport's axiom
    system, this paper determines the extent to which that system differs from
    systems based on atomic or indivisible, actions.  Theorem 1 shows that only
    very weak conditions need be satisfied in addition to the given axioms to
    guarantee the existence of an atomic model while Proposition 1 gives
    sufficient conditions under which any such model must be a faithful
    representation.  Finally, Theorem 2 restates a result of Lamport showing
    exactly when a system can be thought of as made up of a set of atomic
    events that can be totally ordered temporally.  A new constructive proof is
    offered for this result.", 
  location     = "https://doi.org/10.1145/65979.65982"
}

@Article{iftsutsmaat,
  author       = "Schneider, Fred~B.",
  title        = "Implementing Fault-Tolerant Services Using the State Machine Approach: {A} Tutorial",
  journal      = surveys,
  year         = 1990,
  volume       = 22,
  number       = 4,
  pages        = "299--319",
  month        = dec,
  keywords     = "client-server, distributed services, state machines,
    fail-stop processors, byzantine failures", 
  abstract     = "The state machine approach is a general method for
    implementing fault-tolerant services in distributed systems.  This paper
    reviews the approach and describes protocols for two different failure
    models&mdash;Byzantine and fail stop.  Systems reconfiguration techniques
    for removing faulty components and integrating repaired components are also
    discussed.",
  location     = "https://doi.org/10.1145/98163.98167"
}

@Article{ascwfacadpl,
  author       = "Corrodi, Claudio and Heu{\ss}ner, Alexander and Poskitt, Christopher~M.",
  title        = "{A} Semantics Comparison Workbench for a Concurrent, Asynchronous, Distributed Programming Language",
  journal      = "Formal Aspects of Computing",
  year         = 2018,
  volume       = 30,
  number       = 1,
  pages        = "163--192",
  month        = jan,
  keywords     = "concurrent asynchronous programming, distributed programming
    with message passing, operational semantics, runtime semantics, graph
    transformation systems, verification/analysis parameterised by semantics,
    concurrency abstractions, object-oriented programming, software engineering,
    scoop, groove",
  abstract     = "A number of high-level languages and libraries have been
    proposed that offer novel and simple to use abstractions for concurrent,
    asynchronous, and distributed programming.  The execution models that
    realise them, however, often change over time--whether to improve
    performance, or to extend them to new language features--potentially
    affecting behavioural and safety properties of existing programs.  This is
    exemplified by Scoop, a message-passing approach to concurrent
    object-oriented programming that has seen multiple changes proposed and
    implemented, with demonstrable consequences for an idiomatic usage of its
    core abstraction.  We propose a semantics comparison workbench for Scoop
    with fully and semi-automatic tools for analysing and comparing the state
    spaces of programs with respect to different execution models or semantics.
    We demonstrate its use in checking the consistency of properties across
    semantics by applying it to a set of representative programs, and
    highlighting a deadlock-related discrepancy between the principal execution
    models of Scoop.  Furthermore, we demonstrate the extensibility of the
    workbench by generalising the formalisation of an execution model to
    support recently proposed extensions for distributed programming.  Our
    workbench is based on a modular and parameterisable graph transformation
    semantics implemented in the Groove tool.  We discuss how graph
    transformations are leveraged to atomically model intricate language
    abstractions, how the visual yet algebraic nature of the model can be used
    to ascertain soundness, and highlight how the approach could be applied to
    similar languages.", 
  location     = "https://doi.org/10.1007/s00165-017-0443-1"
}

@Article{aifssh,
  author       = "Serpette, Bernard~P. and Serrano, Manuel",
  title        = "An Interpreter for Server-Side {H}op",
  journal      = sigplan # " (" # pot # "Seventh Symposium on Dynamic Languages)",
  year         = 2012,
  volume       = 47,
  number       = 2,
  pages        = "1--12",
  month        = feb,
  keywords     = "functional languages, scheme, interpreter implementation,
    threaded code, optimizations",
  abstract     = "HOP is a Scheme-based multi-tier programming language for the
    Web. The client-side of a program is compiled to JavaScript, while the
    server-side is executed by a mix of natively compiled code and interpreted
    code.  At the time where HOP programs were basic scripts, the performance
    of the server-side interpreter was not a concern; an inefficient
    interpreter was acceptable.  As HOP expanded, HOP programs got larger and
    more complex.  A more efficient interpreter was necessary.  This new
    interpreter is described in this paper.  It is compact, its whole
    implementation counting no more than 2.5 KLOC.  It is more than twice
    faster than the old interpreter and consumes less than a third of its
    memory.  Although it cannot compete with static or JIT native compilers,
    our experimental results show that it is amongst the fastest interpreters
    for dynamic languages.",
  location     = "https://doi.org/10.1145/2168696.2047851"
}

@Article{tgua,
  author       = "Brown, C.~Wayne",
  title        = "Teaching Graphics Using {A}da",
  journal      = "Ada Newsletter (" # pot # "2004 Annual ACM SIGAda International Conference on Ada)",
  year         = 2004,
  volume       = 24,
  number       = 4,
  pages        = "47--50",
  month        = dec,
  keywords     = "graphics, ada, ",
  abstract     = "This paper describes several Ada-language tools supporting a
    computer-graphics course.  These tools include an updated and improved
    OpenGL Ada specification file, a VRML-to-code conversion tool, and an
    Ada-to-C conversion tool.  The tool-development rational and some
    implementation issues are discussed.",
  location     = "https://doi.org/10.1145/1032297.1032306"
}

@InProceedings{amitbpl,
  author       = "Kristensen, Bent Bruun and Madsen, Ole Lehrmann and M{\o}ller-Pedersen, Birger and Nygaard, Kristen",
   title        = "Abstraction Mechanisms in the {B}eta Programming Language",
  booktitle     = pot # "10th Annual " # popl,
  year         = 1983,
  editor       = "Alan Demers and Tim Teitelbaum",
  pages        = "285--298",
  address      = "Austin, Texas",
  month        = "24--26 " # jan,
  keywords     = "language design, object-oriented language, hierarchies,
    subclassing",
  abstract     = "The BETA programming language is developed as part of the
    BETA project.  The purpose of this project is to develop concepts,
    constructs and tools in the field of programming and programming
    languages. BETA has been developed from 1975 on.", 
  location     = "https://doi.org/10.1145/567067.567094"
}

@InProceedings{mdb,
  author       = "Bergel, Alexandre and Ducasse, Stephane and Putney, Colin and Wuyts, Roel",
  title        = "Meta-Driven Browsers",
  booktitle    = "Advances in Smalltalk",
  year         = 2006,
  editor       = "Wolfgang De~Meuter",
  pages        = "134--156",
  publisher    = "Springer",
  address      = "Prague, Czechoslovakia",
  series       = lncs,
  volume       = 4406,
  month        = "4--8 " # sep,
  keywords     = "tools, metamodeling,Â ui, Browsers, squeak, smalltalk, domain
    models",
  abstract     = "Smalltalk is not only an object-oriented programming
    language; it is also known for its extensive integrated development
    environment supporting interactive and dynamic programming.  While the
    default tools are adequate for browsing the code and developing
    applications, it is often cumbersome to extend the environment to support
    new language constructs or to build additional tools supporting new ways of
    navigating and presenting source code.  In this paper, we present the
    OmniBrowser, a browser framework that supports the definition of browsers
    based on an explicit metamodel.  With OmniBrowser a domain model is
    described in a graph and the navigation in this graph is specified in its
    associated metagraph.  We present how new browsers are built from
    predefined parts and how new tools are easily described.  The browser
    framework is implemented in the Squeak Smalltalk environment.  This paper
    shows several concrete instantiations of the framework: a remake of the
    ubiquitous Smalltalk System Browser, and a coverage browser.", 
  location     = "https://doi.org/10.1007/978-3-540-71836-9_7"
}

@InProceedings{acooet,
  author       = "Small, Christopher and Seltzer, Margo",
  title        = "{A} Comparison of {OS} Extension Technologies",
  booktitle    = pot # "1996 USENIX Annual Technical Conference",
  year         = 1996,
  pages        = "41--54",
  address      = sdca,
  month        = "22--26 " # jan,
  keywords     = "operating systems, device drivers, kernel modifications,
    user-space code, up-calls, kernel modules, os security",
  abstract     = "The current trend in operating systems research is to allow
    applications to dynamically extend the kernel to improve application
    performance or extend functionality, but the most effective approach to
    extensibility remains unclear.  Some systems use safe languages to permit
    code to be downloaded directly into the kernel; other systems provide
    in-kernel interpreters to execute extension code; still others use software
    techniques to ensure the safety of kernel extensions.  The key
    characteristics that distinguish these systems are the philosophy behind
    extensibility and the technology used to implement extensibility.  This
    paper presents a taxonomy of the types of extensions that might be
    desirable in an extensible operating system, evaluates the performance cost
    of various extension technologies currently being employed, and compares
    the cost of adding a kernel extension to the benefit of having the
    extension in the kernel.  Our results show that compiled technologies (e.g.
    Modula-3 and software fault isolation) are good candidates for implementing
    general-purpose kernel extensions, but that the overhead of interpreted
    languages is sufficiently high that they are inappropriate for this use.", 
  location     = "https://www.eecs.harvard.edu/margo/papers/usenix96-os/paper.ps"
}

@InProceedings{lddeim,
  author       = "Goel, Shantanu and Duchamp, Dan",
  title        = "Linux Device Driver Emulation in {M}ach",
  booktitle    = pot # "1996 USENIX Annual Technical Conference",
  year         = 1996,
  pages        = "65--74",
  address      = sdca,
  month        = "22--26 " # jan,
  keywords     = "device drivers, linux, mach, emulation",
  abstract     = "We describe the design and performance of code added to the
    Mach microkernel (Mach 4.0, version UK02p21) that permits one to build a
    Mach kernel that includes unmodified Linux device drivers.  We have written
    emulation code to support all Linux 1.3.35 network and SCSI drivers for the
    ISA and PCI I/O buses.  Emulation increases latency, but very little.  The
    degree depends on both device and operation, and varies from 2 microseconds
    for receiving small (60 byte) network packets up to 197 microseconds for
    writing 16KB to an ISA SCSI device.",
  location     = "https://www.usenix.org/publications/library/proceedings/sd96/full_papers/goel.ps"
}

@TechReport{dacsbssbsalbl,
  author       = "P.~Emerald Chung and Yennun Huang and Shalini Yajnik and
    Deron Liang and Joanne~C. Shih and Chung-Yih Wang and Yi-Min Wang",
  title        = "{DCOM} and {CORBA} Side by Side, Step by Step, and Layer by Layer",
  institution  = "Bell Laboratories, Lucent Technologies",
  address      = "Murray Hill, New Jersey",
  keywords     = "corba, dom, distributed computing, architectures",
  abstract     = "DCOM (Distributed Component Object Model) and CORBA (Common
    Object Request Broker Architecture) are two popular distributed object
    models.  In this paper, we make architectural comparison of DCOM and CORBA
    at three different layers: basic programming architecture, remoting
    architecture, and the wire protocol architecture.  A step-by-step
    description of remote object activation and method invocation is provided
    to demonstrate the similarities and differences of the two frameworks.  A
    primary goal is for people who are already familiar with one model to
    quickly understand the basic architecture of the other.",
  location     = "http://research.microsoft.com/~ymwangspapers/HTML/DCOMnCORBA/S.html"
}

@TechReport{crfrtcs,
  author       = "D. Ferrari",
  title        = "Client Requirements for Real-Time Communication Services",
  institution  = "Internet Engineering Task Force, Network Working Group",
  year         = 1990,
  type         = "Request for Comments",
  number       = 1193,
  address      = bca,
  month        = nov,
  keywords     = "client requests, performance, delay, reliability,
    translation",
  abstract     = "A real-time communication service provides its clients with
    the ability to specify their performance requirements and to obtain
    guarantees about the satisfaction of those requirements.  In this paper, we
    propose a set of performance specifications that seem appropriate for such
    services; they include various types of delay bounds, throughput bounds,
    and reliability bounds.  We also describe other requirements and desirable
    properties from a client's viewpoint, and the ways in which each
    requirement is to be translated to make it suitable for lower levels in the
    protocol hierarchy.  Finally, we present some examples of requirements
    specification, and discuss some of the possible objections to our
    approach.", 
  location     = "https://tools.ietf.org/html/rfc1193"
}

@TechReport{agaftalbp,
  author       = "Edward~J. Anderson and Michael~C. Ferris",
  title        = "{A} Genetic Algorithm for the Assembly Line Balancing Problem",
  institution  = "Optimization Group, UW-Madison Computer Sciences, " # uwisc,
  year         = 1990,
  number       = 926,
  address      = madw,
  keywords     = "genetic algorithms, parallel computing",
  abstract     = "",
  location     = "ftp://ftp.cs.wisc.edu/tech-reports/reports/1990/tr926"
}

@TechReport{msltfoesatlosr,
  author       = "Robert~M. Brady and Ross~J. Anderson and Robin~C. Ball",
  title        = "Murphy's Law, the Fitness of Evolving Species, and the Limits of Software Reliability",
  institution  = "Computing Laboratory, Cambridge University",
  year         = 1998,
  type         = "UCAM-CL-TR",
  number       = 471,
  address      = cen,
  month        = sep,
  keywords     = "software reliability, evolving species, reliability growth
    model, software development, poisson distribution, experimental
    measurement, mass market computing, biological evolution, spiral model,
    statistical thermodynamics, software errors, software assurance,
    evolutionary development model observed reliability growth, one-off
    software development",
  abstract     = "We tackle two problems of interest to the software assurance
    community. Firstly, existing models of software development (such as the
    waterfall and spiral models) are oriented towards one-off software
    development projects, while the growth of mass market computing has led to
    a world in which most software consists of packages which follow an
    evolutionary development model.  Thisleads us to ask whether anything
    interesting and useful may be said about evolutionary development.  We
    answer in the afï¬rmative.  Secondly, existing reliability growth models
    emphasise the Poisson distribution of individual software bugs, while the
    empirically observed reliability growth for large systems is asymptotically
    slower than this.  We provide a rigorous explanation of this phenomenon.
    Our reliability growth model is inspired by statistical thermodynamics, but
    also applies to biological evolution.  It is in close agreement with
    experimental measurements of the ï¬tness of an evolving species and the
    reliability of commercial software products.  However, it shows that there
    are signiï¬cant differences between the evolution of software and the
    evolution of species.  In particular, we establish maximisation properties
    corresponding to Murphyâ€™s law which work to the advantage of a biological
    species, but to the detriment of software reliability.", 
  location     = "https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-471.pdf"
}

@TechReport{aniotil,
  author       = "Todd~A. Proebsting and Gregg~M. Townsend",
  title        = "{A} New Implementation of the {I}con Language",
  institution  = csd # uaz,
  year         = 1999,
  number       = "TR 99-13",
  address      = taz,
  abstract     = "We describe Jcon, a new, Java-based implementation of the
    Icon programming language.  The implementation includes a compiler and
    runtime system.  The runtime system is novel in its concise and efficient
    object-oriented implementation of a dynamically typed language, as well as
    its simple mechanism for realizing Icon generators.",
  month        = "4 " # oct,
  keywords     = "icon, java, object-oriented programming, generators, language
    implementation, backtracking, intermediate representations",
  location     = "https://www.microsoft.com/en-us/research/publication/a-new-implementation-of-the-icon-language/"
}

@TechReport{iaf7tcftutsststg,
  author       = "Aaron Sawdey and Matthew O'Keefe and Terrance Parr",
  title        = "Implementing a {F}ortran 77 to {CM} {F}ortran Translator Using the {SORCERER} Source-To-Source Translator Generator",
  institution  = "University of Minnesota",
  year         = 1993,
  type         = "AHPCRC Preprint",
  number       = "93-102",
  month        = oct,
  address      = "",
  keywords     = "language translation, tree transformations, intermediate
    representations, high-performance computing",
  abstract     = "",
  location     = ""
}

@TechReport{ltchamfsp,
  author       = "Lawrence Bernstein and David Klappholz",
  title        = "Live-Through Case Histories as Motivation for Software Process",
  institution  = "New Jersey Center for Software Engineering",
  keywords     = "capstone courses, requirements analysis, case histories,
    project management",
  location     = "http://www.njcse.org/Documents/version40.pdf"
}

@Manual{atajsm,
  title        = "{ANT} Tutorial",
  author       = "Ashley J.~S. Mills",
  organization = "The University of Birmingham",
  year         = 2002,
  keywords     = "build management, xml, java",
  location     = "http://supportweb.cs.bham.ac.uk/docs/tutorials/docsystem/build/tutorials/ant/ant.html"
}

